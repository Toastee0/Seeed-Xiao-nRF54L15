
zephyr.elf:     file format elf32-littleriscv


Disassembly of section rom_start:

2003d000 <__start>:
SECTION_FUNC(vectors, __start)
#if defined(CONFIG_RISCV_GP)
	/* Initialize global pointer */
	.option push
	.option norelax
	la gp, __global_pointer$
2003d000:	00003197          	auipc	gp,0x3
2003d004:	c1018193          	addi	gp,gp,-1008 # 2003fc10 <__global_pointer$>
#endif

	.option norvc;

#if defined(CONFIG_SOC_RESET_HOOK)
	call soc_reset_hook
2003d008:	40c010ef          	jal	ra,2003e414 <SystemInit>
	 * CONFIG_RISCV_TRAP_HANDLER_ALIGNMENT)
	 */
#if defined(CONFIG_USE_ISR_WRAPPER)
	la t0, _isr_wrapper
#else
	add t0, zero, zero
2003d00c:	000002b3          	add	t0,zero,zero
#endif
	addi t0, t0, 0x03 /* Enable CLIC vectored mode by setting LSB */
2003d010:	00328293          	addi	t0,t0,3
	csrw mtvec, t0
2003d014:	30529073          	csrw	mtvec,t0
	 * When an interrupt occurs in CLIC vectored mode, the address of the
	 * handler entry from the vector table is loaded and then jumped to in
	 * hardware. This time mtvt is used as the base address for the
	 * interrupt table.
	 */
	la t0, _irq_vector_table
2003d018:	00000297          	auipc	t0,0x0
2003d01c:	0e828293          	addi	t0,t0,232 # 2003d100 <_irq_vector_table>
	csrw 0x307, t0 /* mtvt */
2003d020:	30729073          	csrw	0x307,t0
#endif /* CONFIG_RISCV_HAS_CLIC&& !CONFIG_LEGACY_CLIC */

#endif /* CONFIG_RISCV_VECTORED_MODE */

	/* Jump to __reset */
	tail __reset
2003d024:	aba1                	j	2003d57c <_vector_end>
	...

2003d100 <_irq_vector_table>:
2003d100:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d110:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d120:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d130:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d140:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d150:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d160:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d170:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d180:	e364 2003 d5f2 2003 d628 2003 d65e 2003     d.. ... (.. ^.. 
2003d190:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d1a0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d1b0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d1c0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d1d0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d1e0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d1f0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d200:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d210:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d220:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d230:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d240:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d250:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d260:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d270:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d280:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d290:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d2a0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d2b0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d2c0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d2d0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d2e0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d2f0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d300:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d310:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d320:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d330:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d340:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d350:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d360:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d370:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d380:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d390:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d3a0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d3b0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d3c0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d3d0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d3e0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d3f0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d400:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d410:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d420:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d430:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d440:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d450:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d460:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d470:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d480:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d490:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d4a0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d4b0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d4c0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d4d0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d4e0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d4f0:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d500:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d510:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d520:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d530:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d540:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d550:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d560:	e0f0 2003 e0f0 2003 e0f0 2003 e0f0 2003     ... ... ... ... 
2003d570:	e0f0 2003 e0f0 2003 e0f0 2003               ... ... ... 

Disassembly of section reset:

2003d57c <__reset>:
	/*
	 * jump to __initialize
	 * use call opcode in case __initialize is far away.
	 * This will be dependent on linker.ld configuration.
	 */
	call __initialize
2003d57c:	2021                	jal	2003d584 <__initialize>
	...

Disassembly of section exceptions:

2003d580 <__soc_handle_irq>:

/*
 * No need to clear anything, pending bit is cleared by HW.
 */
SECTION_FUNC(exception.other, __soc_handle_irq)
	ret
2003d580:	8082                	ret

Disassembly of section text:

2003d584 <__initialize>:
/*
 * Remainder of asm-land initialization code before we can jump into
 * the C domain
 */
SECTION_FUNC(TEXT, __initialize)
	csrr a0, mhartid
2003d584:	f1402573          	csrr	a0,mhartid
	li t0, CONFIG_RV_BOOT_HART
2003d588:	4281                	li	t0,0
	beq a0, t0, boot_first_core
2003d58a:	00550363          	beq	a0,t0,2003d590 <boot_first_core>
	j boot_secondary_core
2003d58e:	a819                	j	2003d5a4 <boot_secondary_core>

2003d590 <boot_first_core>:

	/*
	 * Initially, setup stack pointer to
	 * z_interrupt_stacks + __z_interrupt_stack_SIZEOF
	 */
	la sp, z_interrupt_stacks
2003d590:	00001117          	auipc	sp,0x1
2003d594:	23010113          	addi	sp,sp,560 # 2003e7c0 <z_interrupt_stacks>
	li t0, __z_interrupt_stack_SIZEOF
2003d598:	6285                	lui	t0,0x1
2003d59a:	80028293          	addi	t0,t0,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
	add sp, sp, t0
2003d59e:	9116                	add	sp,sp,t0

	/*
	 * Jump into C domain. z_prep_c zeroes BSS, copies rw data into RAM,
	 * and then enters kernel z_cstart
	 */
	call z_prep_c
2003d5a0:	35f000ef          	jal	ra,2003e0fe <z_prep_c>

2003d5a4 <boot_secondary_core>:
	la t0, riscv_cpu_boot_flag
	li t1, 1
	sr t1, 0(t0)
	j arch_secondary_cpu_init
#else
	j loop_unconfigured_cores
2003d5a4:	a009                	j	2003d5a6 <loop_unconfigured_cores>

2003d5a6 <loop_unconfigured_cores>:
#endif

loop_unconfigured_cores:
	wfi
2003d5a6:	10500073          	wfi
	j loop_unconfigured_cores
2003d5aa:	bff5                	j	2003d5a6 <loop_unconfigured_cores>
	...

2003d5ae <_OffsetAbsSyms>:
GEN_OFFSET_SYM(_cpu_arch_t, user_exc_sp);
GEN_OFFSET_SYM(_cpu_arch_t, user_exc_tmp0);
GEN_OFFSET_SYM(_cpu_arch_t, user_exc_tmp1);
#endif

GEN_ABS_SYM_END
2003d5ae:	8082                	ret

2003d5b0 <hrt_set_bits>:
2003d5b0:	bc002773          	csrr	a4,0xbc0
2003d5b4:	2003e7b7          	lui	a5,0x2003e
2003d5b8:	7207d783          	lhu	a5,1824(a5) # 2003e720 <irq_arg>
2003d5bc:	8fd9                	or	a5,a5,a4
2003d5be:	07c2                	slli	a5,a5,0x10
2003d5c0:	83c1                	srli	a5,a5,0x10
2003d5c2:	bc079073          	csrw	0xbc0,a5
2003d5c6:	8082                	ret

2003d5c8 <hrt_clear_bits>:
2003d5c8:	bc002773          	csrr	a4,0xbc0
2003d5cc:	2003e7b7          	lui	a5,0x2003e
2003d5d0:	7207d783          	lhu	a5,1824(a5) # 2003e720 <irq_arg>
2003d5d4:	fff7c793          	not	a5,a5
2003d5d8:	8ff9                	and	a5,a5,a4
2003d5da:	07c2                	slli	a5,a5,0x10
2003d5dc:	83c1                	srli	a5,a5,0x10
2003d5de:	bc079073          	csrw	0xbc0,a5
2003d5e2:	8082                	ret

2003d5e4 <hrt_toggle_bits>:
2003d5e4:	2003e7b7          	lui	a5,0x2003e
2003d5e8:	7207d783          	lhu	a5,1824(a5) # 2003e720 <irq_arg>
2003d5ec:	bd079073          	csrw	0xbd0,a5
2003d5f0:	8082                	ret

2003d5f2 <hrt_handler_clear_bits>:
	IRQ_DIRECT_CONNECT(vevif, HRT_IRQ_PRIORITY, handler, 0);               \
	nrf_vpr_clic_int_enable_set(NRF_VPRCLIC, VEVIF_IRQN(vevif), true)


__attribute__ ((interrupt)) void hrt_handler_clear_bits(void)
{
2003d5f2:	fd810113          	addi	sp,sp,-40
2003d5f6:	d206                	sw	ra,36(sp)
2003d5f8:	d016                	sw	t0,32(sp)
2003d5fa:	ce1a                	sw	t1,28(sp)
2003d5fc:	cc1e                	sw	t2,24(sp)
2003d5fe:	ca2a                	sw	a0,20(sp)
2003d600:	c82e                	sw	a1,16(sp)
2003d602:	c632                	sw	a2,12(sp)
2003d604:	c436                	sw	a3,8(sp)
2003d606:	c23a                	sw	a4,4(sp)
2003d608:	c03e                	sw	a5,0(sp)
	hrt_clear_bits();
2003d60a:	3f7d                	jal	2003d5c8 <hrt_clear_bits>
}
2003d60c:	5092                	lw	ra,36(sp)
2003d60e:	5282                	lw	t0,32(sp)
2003d610:	4372                	lw	t1,28(sp)
2003d612:	43e2                	lw	t2,24(sp)
2003d614:	4552                	lw	a0,20(sp)
2003d616:	45c2                	lw	a1,16(sp)
2003d618:	4632                	lw	a2,12(sp)
2003d61a:	46a2                	lw	a3,8(sp)
2003d61c:	4712                	lw	a4,4(sp)
2003d61e:	4782                	lw	a5,0(sp)
2003d620:	02810113          	addi	sp,sp,40
2003d624:	30200073          	mret

2003d628 <hrt_handler_set_bits>:

__attribute__ ((interrupt)) void hrt_handler_set_bits(void)
{
2003d628:	fd810113          	addi	sp,sp,-40
2003d62c:	d206                	sw	ra,36(sp)
2003d62e:	d016                	sw	t0,32(sp)
2003d630:	ce1a                	sw	t1,28(sp)
2003d632:	cc1e                	sw	t2,24(sp)
2003d634:	ca2a                	sw	a0,20(sp)
2003d636:	c82e                	sw	a1,16(sp)
2003d638:	c632                	sw	a2,12(sp)
2003d63a:	c436                	sw	a3,8(sp)
2003d63c:	c23a                	sw	a4,4(sp)
2003d63e:	c03e                	sw	a5,0(sp)
	hrt_set_bits();
2003d640:	3f85                	jal	2003d5b0 <hrt_set_bits>
}
2003d642:	5092                	lw	ra,36(sp)
2003d644:	5282                	lw	t0,32(sp)
2003d646:	4372                	lw	t1,28(sp)
2003d648:	43e2                	lw	t2,24(sp)
2003d64a:	4552                	lw	a0,20(sp)
2003d64c:	45c2                	lw	a1,16(sp)
2003d64e:	4632                	lw	a2,12(sp)
2003d650:	46a2                	lw	a3,8(sp)
2003d652:	4712                	lw	a4,4(sp)
2003d654:	4782                	lw	a5,0(sp)
2003d656:	02810113          	addi	sp,sp,40
2003d65a:	30200073          	mret

2003d65e <hrt_handler_toggle_bits>:

__attribute__ ((interrupt)) void hrt_handler_toggle_bits(void)
{
2003d65e:	fd810113          	addi	sp,sp,-40
2003d662:	d206                	sw	ra,36(sp)
2003d664:	d016                	sw	t0,32(sp)
2003d666:	ce1a                	sw	t1,28(sp)
2003d668:	cc1e                	sw	t2,24(sp)
2003d66a:	ca2a                	sw	a0,20(sp)
2003d66c:	c82e                	sw	a1,16(sp)
2003d66e:	c632                	sw	a2,12(sp)
2003d670:	c436                	sw	a3,8(sp)
2003d672:	c23a                	sw	a4,4(sp)
2003d674:	c03e                	sw	a5,0(sp)
	hrt_toggle_bits();
2003d676:	37bd                	jal	2003d5e4 <hrt_toggle_bits>
}
2003d678:	5092                	lw	ra,36(sp)
2003d67a:	5282                	lw	t0,32(sp)
2003d67c:	4372                	lw	t1,28(sp)
2003d67e:	43e2                	lw	t2,24(sp)
2003d680:	4552                	lw	a0,20(sp)
2003d682:	45c2                	lw	a1,16(sp)
2003d684:	4632                	lw	a2,12(sp)
2003d686:	46a2                	lw	a3,8(sp)
2003d688:	4712                	lw	a4,4(sp)
2003d68a:	4782                	lw	a5,0(sp)
2003d68c:	02810113          	addi	sp,sp,40
2003d690:	30200073          	mret

2003d694 <process_packet>:
	if (packet->port != 2) {
2003d694:	00554783          	lbu	a5,5(a0)
2003d698:	4709                	li	a4,2
2003d69a:	1ce79063          	bne	a5,a4,2003d85a <process_packet+0x1c6>
	switch (packet->opcode) {
2003d69e:	00054703          	lbu	a4,0(a0)
2003d6a2:	16f70b63          	beq	a4,a5,2003d818 <process_packet+0x184>
2003d6a6:	06e7e363          	bltu	a5,a4,2003d70c <process_packet+0x78>
2003d6aa:	00154683          	lbu	a3,1(a0)
2003d6ae:	00254783          	lbu	a5,2(a0)
2003d6b2:	14071663          	bnez	a4,2003d7fe <process_packet+0x16a>
		gpio_hpf_pin_configure(packet->port, packet->pin, packet->flags);
2003d6b6:	07a2                	slli	a5,a5,0x8
2003d6b8:	8edd                	or	a3,a3,a5
2003d6ba:	00754783          	lbu	a5,7(a0)
2003d6be:	00654703          	lbu	a4,6(a0)
2003d6c2:	01f6f613          	andi	a2,a3,31
2003d6c6:	07a2                	slli	a5,a5,0x8
2003d6c8:	8fd9                	or	a5,a5,a4
2003d6ca:	00854703          	lbu	a4,8(a0)
		return NRF_GPIO_PIN_PULLUP;
2003d6ce:	430d                	li	t1,3
		gpio_hpf_pin_configure(packet->port, packet->pin, packet->flags);
2003d6d0:	0742                	slli	a4,a4,0x10
2003d6d2:	8f5d                	or	a4,a4,a5
2003d6d4:	00954783          	lbu	a5,9(a0)
2003d6d8:	07e2                	slli	a5,a5,0x18
2003d6da:	8fd9                	or	a5,a5,a4
	if (flags & GPIO_PULL_UP) {
2003d6dc:	8b41                	andi	a4,a4,16
2003d6de:	e709                	bnez	a4,2003d6e8 <process_packet+0x54>
	} else if (flags & GPIO_PULL_DOWN) {
2003d6e0:	0057d313          	srli	t1,a5,0x5
2003d6e4:	00137313          	andi	t1,t1,1
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
2003d6e8:	3067f513          	andi	a0,a5,774
2003d6ec:	10600713          	li	a4,262
2003d6f0:	0ee50063          	beq	a0,a4,2003d7d0 <process_packet+0x13c>
2003d6f4:	02a76563          	bltu	a4,a0,2003d71e <process_packet+0x8a>
2003d6f8:	4719                	li	a4,6
2003d6fa:	0ce50d63          	beq	a0,a4,2003d7d4 <process_packet+0x140>
2003d6fe:	00a76b63          	bltu	a4,a0,2003d714 <process_packet+0x80>
2003d702:	c91d                	beqz	a0,2003d738 <process_packet+0xa4>
2003d704:	4709                	li	a4,2
2003d706:	02e50963          	beq	a0,a4,2003d738 <process_packet+0xa4>
2003d70a:	8082                	ret
	switch (packet->opcode) {
2003d70c:	478d                	li	a5,3
2003d70e:	12f70663          	beq	a4,a5,2003d83a <process_packet+0x1a6>
2003d712:	8082                	ret
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
2003d714:	10000713          	li	a4,256
2003d718:	0ce50063          	beq	a0,a4,2003d7d8 <process_packet+0x144>
2003d71c:	8082                	ret
2003d71e:	20200713          	li	a4,514
2003d722:	0ae50d63          	beq	a0,a4,2003d7dc <process_packet+0x148>
2003d726:	30000713          	li	a4,768
2003d72a:	0ae50b63          	beq	a0,a4,2003d7e0 <process_packet+0x14c>
2003d72e:	20000713          	li	a4,512
2003d732:	12e51463          	bne	a0,a4,2003d85a <process_packet+0x1c6>
		drive = NRF_GPIO_PIN_S0H1;
2003d736:	4511                	li	a0,4
	if (flags & GPIO_OUTPUT_INIT_HIGH) {
2003d738:	00080737          	lui	a4,0x80
2003d73c:	8f7d                	and	a4,a4,a5
2003d73e:	c35d                	beqz	a4,2003d7e4 <process_packet+0x150>
    nrf_csr_write(VPRCSR_NORDIC_INMODEB, mode);
}

NRF_STATIC_INLINE uint16_t nrf_vpr_csr_vio_out_get(void)
{
    return (uint16_t)nrf_csr_read(VPRCSR_NORDIC_OUT);
2003d740:	bc0025f3          	csrr	a1,0xbc0
		nrf_vpr_csr_vio_out_set(outs | (BIT(pin)));
2003d744:	4705                	li	a4,1
2003d746:	00d71733          	sll	a4,a4,a3
2003d74a:	8f4d                	or	a4,a4,a1
}

NRF_STATIC_INLINE void nrf_vpr_csr_vio_out_set(uint16_t value)
{
    nrf_csr_write(VPRCSR_NORDIC_OUT, value);
2003d74c:	0742                	slli	a4,a4,0x10
2003d74e:	8341                	srli	a4,a4,0x10
2003d750:	bc071073          	csrw	0xbc0,a4
	nrf_gpio_pin_dir_t dir =
2003d754:	50050737          	lui	a4,0x50050
2003d758:	40070713          	addi	a4,a4,1024 # 50050400 <__global_pointer$+0x300107f0>
2003d75c:	060a                	slli	a2,a2,0x2
2003d75e:	963a                	add	a2,a2,a4
		(flags & GPIO_INPUT) ? NRF_GPIO_PIN_INPUT_CONNECT : NRF_GPIO_PIN_INPUT_DISCONNECT;
2003d760:	0107d713          	srli	a4,a5,0x10
                                            const nrf_gpio_pin_pull_t *  p_pull,
                                            const nrf_gpio_pin_drive_t * p_drive,
                                            const nrf_gpio_pin_sense_t * p_sense)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    uint32_t cnf = reg->PIN_CNF[pin_number];
2003d764:	08062283          	lw	t0,128(a2)
2003d768:	00174713          	xori	a4,a4,1
		(flags & GPIO_OUTPUT) ? NRF_GPIO_PIN_DIR_OUTPUT : NRF_GPIO_PIN_DIR_INPUT;
2003d76c:	0117d593          	srli	a1,a5,0x11
		(flags & GPIO_INPUT) ? NRF_GPIO_PIN_INPUT_CONNECT : NRF_GPIO_PIN_INPUT_DISCONNECT;
2003d770:	8b05                	andi	a4,a4,1
                         (p_drive ? (GPIO_PIN_CNF_DRIVE0_Msk | GPIO_PIN_CNF_DRIVE1_Msk) : 0) |
#endif
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk                              : 0);

    /* Clear fields that will be updated. */
    cnf &= ~to_update;
2003d772:	77fd                	lui	a5,0xfffff
2003d774:	8985                	andi	a1,a1,1
2003d776:	0f078793          	addi	a5,a5,240 # fffff0f0 <CONFIG_MCUBOOT_APPLICATION_IMAGE_NUMBER+0xfffff0f1>
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)    |
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos)  |
2003d77a:	0706                	slli	a4,a4,0x1
    cnf &= ~to_update;
2003d77c:	00f2f2b3          	and	t0,t0,a5
2003d780:	8f4d                	or	a4,a4,a1
2003d782:	00576733          	or	a4,a4,t0
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)   |
2003d786:	030a                	slli	t1,t1,0x2
2003d788:	00676733          	or	a4,a4,t1
#if defined(GPIO_PIN_CNF_DRIVE_Pos)
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos)  |
#else
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE0_Pos) |
2003d78c:	00851793          	slli	a5,a0,0x8
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)    |
2003d790:	8fd9                	or	a5,a5,a4
#endif
           ((uint32_t)(p_sense ? *p_sense : 0)<< GPIO_PIN_CNF_SENSE_Pos);

    reg->PIN_CNF[pin_number] = cnf;
2003d792:	08f62023          	sw	a5,128(a2)
}

NRF_STATIC_INLINE void nrf_barrier_w(void)
{
#if defined(ISA_RISCV)
    RISCV_FENCE(ow, ow);
2003d796:	0550000f          	fence	ow,ow
	if (dir == NRF_GPIO_PIN_DIR_OUTPUT) {
2003d79a:	c999                	beqz	a1,2003d7b0 <process_packet+0x11c>
    return (uint16_t)nrf_csr_read(VPRCSR_NORDIC_DIR);
2003d79c:	bc102773          	csrr	a4,0xbc1
		nrf_vpr_csr_vio_dir_set(nrf_vpr_csr_vio_dir_get() | (BIT(pin)));
2003d7a0:	4785                	li	a5,1
2003d7a2:	00d797b3          	sll	a5,a5,a3
2003d7a6:	8fd9                	or	a5,a5,a4
    nrf_csr_write(VPRCSR_NORDIC_DIR, value);
2003d7a8:	07c2                	slli	a5,a5,0x10
2003d7aa:	83c1                	srli	a5,a5,0x10
2003d7ac:	bc179073          	csrw	0xbc1,a5
}

NRF_STATIC_INLINE void nrf_barrier_r(void)
{
#if defined(ISA_RISCV)
    RISCV_FENCE(ir, ir);
2003d7b0:	0aa0000f          	fence	ir,ir
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
#if defined(GPIO_PIN_CNF_MCUSEL_Msk)
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_MCUSEL_Msk;
    reg->PIN_CNF[pin_number] = cnf | (ctrl << GPIO_PIN_CNF_MCUSEL_Pos);
#else
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_CTRLSEL_Msk;
2003d7b4:	08062783          	lw	a5,128(a2)
2003d7b8:	90000737          	lui	a4,0x90000
2003d7bc:	177d                	addi	a4,a4,-1 # 8fffffff <CONFIG_MCUBOOT_APPLICATION_IMAGE_NUMBER+0x90000000>
2003d7be:	8ff9                	and	a5,a5,a4
    reg->PIN_CNF[pin_number] = cnf | (ctrl << GPIO_PIN_CNF_CTRLSEL_Pos);
2003d7c0:	10000737          	lui	a4,0x10000
2003d7c4:	8fd9                	or	a5,a5,a4
2003d7c6:	08f62023          	sw	a5,128(a2)
}

NRF_STATIC_INLINE void nrf_barrier_rw(void)
{
#if defined(ISA_RISCV)
    RISCV_FENCE(iorw, iorw);
2003d7ca:	0ff0000f          	fence
	return 0;
2003d7ce:	8082                	ret
		drive = NRF_GPIO_PIN_H0D1;
2003d7d0:	4525                	li	a0,9
2003d7d2:	b79d                	j	2003d738 <process_packet+0xa4>
		drive = NRF_GPIO_PIN_S0D1;
2003d7d4:	4521                	li	a0,8
2003d7d6:	b78d                	j	2003d738 <process_packet+0xa4>
		drive = NRF_GPIO_PIN_H0S1;
2003d7d8:	4505                	li	a0,1
2003d7da:	bfb9                	j	2003d738 <process_packet+0xa4>
		drive = NRF_GPIO_PIN_D0H1;
2003d7dc:	4519                	li	a0,6
2003d7de:	bfa9                	j	2003d738 <process_packet+0xa4>
		drive = NRF_GPIO_PIN_H0H1;
2003d7e0:	4515                	li	a0,5
2003d7e2:	bf99                	j	2003d738 <process_packet+0xa4>
	} else if (flags & GPIO_OUTPUT_INIT_LOW) {
2003d7e4:	00040737          	lui	a4,0x40
2003d7e8:	8f7d                	and	a4,a4,a5
2003d7ea:	d72d                	beqz	a4,2003d754 <process_packet+0xc0>
    return (uint16_t)nrf_csr_read(VPRCSR_NORDIC_OUT);
2003d7ec:	bc0025f3          	csrr	a1,0xbc0
		nrf_vpr_csr_vio_out_set(outs & ~(BIT(pin)));
2003d7f0:	4705                	li	a4,1
2003d7f2:	00d71733          	sll	a4,a4,a3
2003d7f6:	fff74713          	not	a4,a4
2003d7fa:	8f6d                	and	a4,a4,a1
2003d7fc:	bf81                	j	2003d74c <process_packet+0xb8>
		irq_arg = packet->pin;
2003d7fe:	07a2                	slli	a5,a5,0x8
2003d800:	8fd5                	or	a5,a5,a3
2003d802:	2003e737          	lui	a4,0x2003e
2003d806:	72f71023          	sh	a5,1824(a4) # 2003e720 <irq_arg>
}

NRF_STATIC_INLINE void nrf_vpr_clic_int_pending_set(NRF_CLIC_Type * p_reg, uint32_t irq_num)
{
    NRFX_ASSERT(irq_num < NRF_VPR_CLIC_IRQ_COUNT);
    p_reg->CLIC.CLICINT[irq_num] = (p_reg->CLIC.CLICINT[irq_num] & ~CLIC_CLIC_CLICINT_IP_Msk) |
2003d80a:	f0001737          	lui	a4,0xf0001
2003d80e:	437c                	lw	a5,68(a4)
2003d810:	0017e793          	ori	a5,a5,1
2003d814:	c37c                	sw	a5,68(a4)
                                   (CLIC_CLIC_CLICINT_IP_Pending << CLIC_CLIC_CLICINT_IP_Pos);
}
2003d816:	8082                	ret
		irq_arg = packet->pin;
2003d818:	00254783          	lbu	a5,2(a0)
2003d81c:	00154703          	lbu	a4,1(a0)
2003d820:	07a2                	slli	a5,a5,0x8
2003d822:	8fd9                	or	a5,a5,a4
2003d824:	2003e737          	lui	a4,0x2003e
2003d828:	72f71023          	sh	a5,1824(a4) # 2003e720 <irq_arg>
    p_reg->CLIC.CLICINT[irq_num] = (p_reg->CLIC.CLICINT[irq_num] & ~CLIC_CLIC_CLICINT_IP_Msk) |
2003d82c:	f0001737          	lui	a4,0xf0001
2003d830:	473c                	lw	a5,72(a4)
2003d832:	0017e793          	ori	a5,a5,1
2003d836:	c73c                	sw	a5,72(a4)
}
2003d838:	8082                	ret
		irq_arg = packet->pin;
2003d83a:	00254783          	lbu	a5,2(a0)
2003d83e:	00154703          	lbu	a4,1(a0)
2003d842:	07a2                	slli	a5,a5,0x8
2003d844:	8fd9                	or	a5,a5,a4
2003d846:	2003e737          	lui	a4,0x2003e
2003d84a:	72f71023          	sh	a5,1824(a4) # 2003e720 <irq_arg>
    p_reg->CLIC.CLICINT[irq_num] = (p_reg->CLIC.CLICINT[irq_num] & ~CLIC_CLIC_CLICINT_IP_Msk) |
2003d84e:	f0001737          	lui	a4,0xf0001
2003d852:	477c                	lw	a5,76(a4)
2003d854:	0017e793          	ori	a5,a5,1
2003d858:	c77c                	sw	a5,76(a4)
}
2003d85a:	8082                	ret

2003d85c <main>:

int main(void)
{
	int ret = 0;

	ret = backend_init(process_packet);
2003d85c:	2003d537          	lui	a0,0x2003d
{
2003d860:	1151                	addi	sp,sp,-12
	ret = backend_init(process_packet);
2003d862:	69450513          	addi	a0,a0,1684 # 2003d694 <process_packet>
{
2003d866:	c406                	sw	ra,8(sp)
2003d868:	c222                	sw	s0,4(sp)
	ret = backend_init(process_packet);
2003d86a:	2049                	jal	2003d8ec <backend_init>
	if (ret < 0) {
2003d86c:	06054163          	bltz	a0,2003d8ce <main+0x72>
		return 0;
	}

	HRT_CONNECT(HRT_VEVIF_IDX_GPIO_CLEAR, hrt_handler_clear_bits);
2003d870:	4601                	li	a2,0
2003d872:	4589                	li	a1,2
2003d874:	4545                	li	a0,17
2003d876:	20dd                	jal	2003d95c <z_riscv_irq_priority_set>
2003d878:	4545                	li	a0,17
2003d87a:	20dd                	jal	2003d960 <z_riscv_irq_vector_set>
NRF_STATIC_INLINE void nrf_vpr_clic_int_enable_set(NRF_CLIC_Type * p_reg,
                                                   uint32_t        irq_num,
                                                   bool            enable)
{
    NRFX_ASSERT(irq_num < NRF_VPR_CLIC_IRQ_COUNT);
    p_reg->CLIC.CLICINT[irq_num] = (p_reg->CLIC.CLICINT[irq_num] & ~CLIC_CLIC_CLICINT_IE_Msk) |
2003d87c:	f0001437          	lui	s0,0xf0001
2003d880:	407c                	lw	a5,68(s0)
	HRT_CONNECT(HRT_VEVIF_IDX_GPIO_SET, hrt_handler_set_bits);
2003d882:	4601                	li	a2,0
2003d884:	4589                	li	a1,2
2003d886:	1007e793          	ori	a5,a5,256
2003d88a:	c07c                	sw	a5,68(s0)
2003d88c:	4549                	li	a0,18
2003d88e:	20f9                	jal	2003d95c <z_riscv_irq_priority_set>
2003d890:	4549                	li	a0,18
2003d892:	20f9                	jal	2003d960 <z_riscv_irq_vector_set>
2003d894:	443c                	lw	a5,72(s0)
	HRT_CONNECT(HRT_VEVIF_IDX_GPIO_TOGGLE, hrt_handler_toggle_bits);
2003d896:	4601                	li	a2,0
2003d898:	4589                	li	a1,2
2003d89a:	1007e793          	ori	a5,a5,256
2003d89e:	c43c                	sw	a5,72(s0)
2003d8a0:	454d                	li	a0,19
2003d8a2:	286d                	jal	2003d95c <z_riscv_irq_priority_set>
2003d8a4:	454d                	li	a0,19
2003d8a6:	286d                	jal	2003d960 <z_riscv_irq_vector_set>
2003d8a8:	447c                	lw	a5,76(s0)
2003d8aa:	1007e793          	ori	a5,a5,256
2003d8ae:	c47c                	sw	a5,76(s0)
    return nrf_csr_read(VPRCSR_MINSTRET) | ((uint64_t)nrf_csr_read(VPRCSR_MINSTRETH) << 32);
}

NRF_STATIC_INLINE void nrf_vpr_csr_rtperiph_enable_set(bool enable)
{
    uint32_t reg = nrf_csr_read(VPRCSR_NORDIC_VPRNORDICCTRL);
2003d8b0:	7c0027f3          	csrr	a5,0x7c0
    reg = (reg & ~VPRCSR_NORDIC_VPRNORDICCTRL_ENABLERTPERIPH_Msk) | NRF_VPR_CSR_NORDIC_KEY_MASK;
2003d8b4:	af830737          	lui	a4,0xaf830
2003d8b8:	1779                	addi	a4,a4,-2 # af82fffe <CONFIG_MCUBOOT_APPLICATION_IMAGE_NUMBER+0xaf82ffff>
2003d8ba:	8ff9                	and	a5,a5,a4

    reg |= ((enable ? VPRCSR_NORDIC_VPRNORDICCTRL_ENABLERTPERIPH_Enabled :
2003d8bc:	507d0737          	lui	a4,0x507d0
2003d8c0:	0705                	addi	a4,a4,1 # 507d0001 <__global_pointer$+0x307903f1>
2003d8c2:	8fd9                	or	a5,a5,a4
                      VPRCSR_NORDIC_VPRNORDICCTRL_ENABLERTPERIPH_Disabled)
            << VPRCSR_NORDIC_VPRNORDICCTRL_ENABLERTPERIPH_Pos) | NRF_VPR_CSR_NORDIC_KEY_MASK;

    nrf_csr_write(VPRCSR_NORDIC_VPRNORDICCTRL, reg);
2003d8c4:	7c079073          	csrw	0x7c0,a5
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
2003d8c8:	7e2000ef          	jal	ra,2003e0aa <arch_cpu_idle>
2003d8cc:	bff5                	j	2003d8c8 <main+0x6c>
	while (true) {
		k_cpu_idle();
	}

	return 0;
}
2003d8ce:	40a2                	lw	ra,8(sp)
2003d8d0:	4412                	lw	s0,4(sp)
2003d8d2:	4501                	li	a0,0
2003d8d4:	0131                	addi	sp,sp,12
2003d8d6:	8082                	ret

2003d8d8 <ep_bound>:
static backend_callback_t cbck;
static volatile uint32_t bound_sem = 1;

static void ep_bound(void *priv)
{
	bound_sem = 0;
2003d8d8:	2003f7b7          	lui	a5,0x2003f
2003d8dc:	4007a823          	sw	zero,1040(a5) # 2003f410 <bound_sem>
}
2003d8e0:	8082                	ret

2003d8e2 <ep_recv>:
static void ep_recv(const void *data, size_t len, void *priv)
{
	(void)len;
	(void)priv;

	cbck((hpf_gpio_data_packet_t *)data);
2003d8e2:	2003e7b7          	lui	a5,0x2003e
2003d8e6:	7147a783          	lw	a5,1812(a5) # 2003e714 <cbck>
2003d8ea:	8782                	jr	a5

2003d8ec <backend_init>:
		.received = ep_recv,
	},
};

int backend_init(backend_callback_t callback)
{
2003d8ec:	1141                	addi	sp,sp,-16
	int ret = 0;
	const struct device *ipc0_instance;
	volatile uint32_t delay = 0;
	cbck = callback;
2003d8ee:	2003e7b7          	lui	a5,0x2003e
{
2003d8f2:	c606                	sw	ra,12(sp)
2003d8f4:	c422                	sw	s0,8(sp)
	volatile uint32_t delay = 0;
2003d8f6:	c002                	sw	zero,0(sp)
	cbck = callback;
2003d8f8:	70a7aa23          	sw	a0,1812(a5) # 2003e714 <cbck>

#if !defined(CONFIG_SYS_CLOCK_EXISTS)
	/* Wait a little bit for IPC service to be ready on APP side */
	while (delay < 1000) {
2003d8fc:	3e700713          	li	a4,999
2003d900:	4782                	lw	a5,0(sp)
2003d902:	04f77463          	bgeu	a4,a5,2003d94a <backend_init+0x5e>
	}
#endif

	ipc0_instance = DEVICE_DT_GET(DT_NODELABEL(ipc0));

	ret = ipc_service_open_instance(ipc0_instance);
2003d906:	2003e437          	lui	s0,0x2003e
2003d90a:	60840513          	addi	a0,s0,1544 # 2003e608 <__device_dts_ord_28>
2003d90e:	2891                	jal	2003d962 <ipc_service_open_instance>
	if ((ret < 0) && (ret != -EALREADY)) {
2003d910:	00055663          	bgez	a0,2003d91c <backend_init+0x30>
2003d914:	f8800793          	li	a5,-120
2003d918:	02f51563          	bne	a0,a5,2003d942 <backend_init+0x56>
		return ret;
	}

	ret = ipc_service_register_endpoint(ipc0_instance, &ep, &ep_cfg);
2003d91c:	2003f637          	lui	a2,0x2003f
2003d920:	2003e5b7          	lui	a1,0x2003e
2003d924:	3c060613          	addi	a2,a2,960 # 2003f3c0 <ep_cfg>
2003d928:	71858593          	addi	a1,a1,1816 # 2003e718 <ep>
2003d92c:	60840513          	addi	a0,s0,1544
2003d930:	20a9                	jal	2003d97a <ipc_service_register_endpoint>
	if (ret < 0) {
2003d932:	00054863          	bltz	a0,2003d942 <backend_init+0x56>
		return ret;
	}

	/* Wait for endpoint to be bound */
	while (bound_sem != 0) {
2003d936:	2003f737          	lui	a4,0x2003f
2003d93a:	41072783          	lw	a5,1040(a4) # 2003f410 <bound_sem>
2003d93e:	fff5                	bnez	a5,2003d93a <backend_init+0x4e>
	};

	return 0;
2003d940:	4501                	li	a0,0
}
2003d942:	40b2                	lw	ra,12(sp)
2003d944:	4422                	lw	s0,8(sp)
2003d946:	0141                	addi	sp,sp,16
2003d948:	8082                	ret
		delay++;
2003d94a:	4782                	lw	a5,0(sp)
2003d94c:	0785                	addi	a5,a5,1
2003d94e:	c03e                	sw	a5,0(sp)
2003d950:	bf45                	j	2003d900 <backend_init+0x14>

2003d952 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_CHECK_INIT_PRIORITIES, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_ENFORCE_ZEPHYR_STDINT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_LEGACY_GENERATED_INCLUDE_PATH, 1);

GEN_ABS_SYM_END
2003d952:	8082                	ret

2003d954 <arch_irq_enable>:

#if defined(CONFIG_RISCV_HAS_CLIC)

void arch_irq_enable(unsigned int irq)
{
	riscv_clic_irq_enable(irq);
2003d954:	12b0006f          	j	2003e27e <riscv_clic_irq_enable>

2003d958 <arch_irq_disable>:
}

void arch_irq_disable(unsigned int irq)
{
	riscv_clic_irq_disable(irq);
2003d958:	1390006f          	j	2003e290 <riscv_clic_irq_disable>

2003d95c <z_riscv_irq_priority_set>:
	return riscv_clic_irq_is_enabled(irq);
}

void z_riscv_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
	riscv_clic_irq_priority_set(irq, prio, flags);
2003d95c:	1470006f          	j	2003e2a2 <riscv_clic_irq_priority_set>

2003d960 <z_riscv_irq_vector_set>:
#if defined(CONFIG_CLIC_SMCLICSHV_EXT)
	riscv_clic_irq_vector_set(irq);
#else
	ARG_UNUSED(irq);
#endif
}
2003d960:	8082                	ret

2003d962 <ipc_service_open_instance>:

int ipc_service_open_instance(const struct device *instance)
{
	const struct ipc_service_backend *backend;

	if (!instance) {
2003d962:	c511                	beqz	a0,2003d96e <ipc_service_open_instance+0xc>
		LOG_ERR("Invalid instance");
		return -EINVAL;
	}

	backend = (const struct ipc_service_backend *) instance->api;
2003d964:	451c                	lw	a5,8(a0)

	if (!backend) {
2003d966:	c791                	beqz	a5,2003d972 <ipc_service_open_instance+0x10>
		LOG_ERR("Invalid backend configuration");
		return -EIO;
	}

	if (!backend->open_instance) {
2003d968:	439c                	lw	a5,0(a5)
2003d96a:	c791                	beqz	a5,2003d976 <ipc_service_open_instance+0x14>
		/* maybe not needed on backend */
		return 0;
	}

	return backend->open_instance(instance);
2003d96c:	8782                	jr	a5
		return -EINVAL;
2003d96e:	5529                	li	a0,-22
2003d970:	8082                	ret
		return -EIO;
2003d972:	556d                	li	a0,-5
2003d974:	8082                	ret
		return 0;
2003d976:	4501                	li	a0,0
}
2003d978:	8082                	ret

2003d97a <ipc_service_register_endpoint>:
				  struct ipc_ept *ept,
				  const struct ipc_ept_cfg *cfg)
{
	const struct ipc_service_backend *backend;

	if (!instance || !ept || !cfg) {
2003d97a:	c919                	beqz	a0,2003d990 <ipc_service_register_endpoint+0x16>
2003d97c:	c991                	beqz	a1,2003d990 <ipc_service_register_endpoint+0x16>
2003d97e:	ca09                	beqz	a2,2003d990 <ipc_service_register_endpoint+0x16>
		LOG_ERR("Invalid instance, endpoint or configuration");
		return -EINVAL;
	}

	backend = (const struct ipc_service_backend *) instance->api;
2003d980:	4518                	lw	a4,8(a0)

	if (!backend || !backend->register_endpoint) {
2003d982:	cb09                	beqz	a4,2003d994 <ipc_service_register_endpoint+0x1a>
2003d984:	4754                	lw	a3,12(a4)
2003d986:	c699                	beqz	a3,2003d994 <ipc_service_register_endpoint+0x1a>
		return -EIO;
	}

	LOG_DBG("Register endpoint %s", cfg->name ? cfg->name : "");

	ept->instance = instance;
2003d988:	c188                	sw	a0,0(a1)

	return backend->register_endpoint(instance, &ept->token, cfg);
2003d98a:	475c                	lw	a5,12(a4)
2003d98c:	0591                	addi	a1,a1,4
2003d98e:	8782                	jr	a5
		return -EINVAL;
2003d990:	5529                	li	a0,-22
2003d992:	8082                	ret
		return -EIO;
2003d994:	556d                	li	a0,-5
}
2003d996:	8082                	ret

2003d998 <backend_init>:
};

static int backend_init(const struct device *instance)
{
	return 0;
}
2003d998:	4501                	li	a0,0
2003d99a:	8082                	ret

2003d99c <deregister_ept>:
	return icmsg_close(conf, dev_data);
2003d99c:	490c                	lw	a1,16(a0)
2003d99e:	4148                	lw	a0,4(a0)
2003d9a0:	a689                	j	2003dce2 <icmsg_close>

2003d9a2 <register_ept>:
{
2003d9a2:	87aa                	mv	a5,a0
	struct icmsg_data_t *dev_data = instance->data;
2003d9a4:	4b9c                	lw	a5,16(a5)
	const struct icmsg_config_t *conf = instance->config;
2003d9a6:	4148                	lw	a0,4(a0)
	*token = NULL;
2003d9a8:	0005a023          	sw	zero,0(a1)
	return icmsg_open(conf, dev_data, &cfg->cb, cfg->priv);
2003d9ac:	4e14                	lw	a3,24(a2)
2003d9ae:	85be                	mv	a1,a5
2003d9b0:	0621                	addi	a2,a2,8
2003d9b2:	a499                	j	2003dbf8 <icmsg_open>

2003d9b4 <send>:
	return icmsg_send(conf, dev_data, msg, len);
2003d9b4:	490c                	lw	a1,16(a0)
2003d9b6:	4148                	lw	a0,4(a0)
2003d9b8:	a661                	j	2003dd40 <icmsg_send>

2003d9ba <atomic_set>:
		union { uintptr_t x; atomic_val_t val; } parm1 = { .val = value };
		return (atomic_val_t) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_ATOMIC_SET);
	}
#endif
	compiler_barrier();
	return z_impl_atomic_set(target, value);
2003d9ba:	33d0006f          	j	2003e4f6 <z_impl_atomic_set>

2003d9be <mbox_send_dt.constprop.0>:
 * @param spec MBOX specification from devicetree
 * @param msg Message
 *
 * @return See return values for mbox_send()
 */
static inline int mbox_send_dt(const struct mbox_dt_spec *spec,
2003d9be:	87aa                	mv	a5,a0
			       const struct mbox_msg *msg)
{
	return mbox_send(spec->dev, spec->channel_id, msg);
2003d9c0:	43cc                	lw	a1,4(a5)
2003d9c2:	4108                	lw	a0,0(a0)
	if (api->send == NULL) {
2003d9c4:	451c                	lw	a5,8(a0)
2003d9c6:	439c                	lw	a5,0(a5)
2003d9c8:	c399                	beqz	a5,2003d9ce <mbox_send_dt.constprop.0+0x10>
	return api->send(dev, channel_id, msg);
2003d9ca:	4601                	li	a2,0
2003d9cc:	8782                	jr	a5
}
2003d9ce:	fa800513          	li	a0,-88
2003d9d2:	8082                	ret

2003d9d4 <initialize_tx_with_sid_disabled>:
}

#endif

static int initialize_tx_with_sid_disabled(struct icmsg_data_t *dev_data)
{
2003d9d4:	1151                	addi	sp,sp,-12
2003d9d6:	c222                	sw	s0,4(sp)
2003d9d8:	c406                	sw	ra,8(sp)
2003d9da:	842a                	mv	s0,a0
	int ret;

	ret = pbuf_tx_init(dev_data->tx_pb);
2003d9dc:	4108                	lw	a0,0(a0)
2003d9de:	2125                	jal	2003de06 <pbuf_tx_init>

	if (ret < 0) {
2003d9e0:	00054f63          	bltz	a0,2003d9fe <initialize_tx_with_sid_disabled+0x2a>
		__ASSERT(false, "Incorrect Tx configuration");
		return ret;
	}

	ret = pbuf_write(dev_data->tx_pb, magic, sizeof(magic));
2003d9e4:	4008                	lw	a0,0(s0)
2003d9e6:	2003e5b7          	lui	a1,0x2003e
2003d9ea:	4635                	li	a2,13
2003d9ec:	6e458593          	addi	a1,a1,1764 # 2003e6e4 <magic>
2003d9f0:	298d                	jal	2003de62 <pbuf_write>

	if (ret < 0) {
2003d9f2:	00054663          	bltz	a0,2003d9fe <initialize_tx_with_sid_disabled+0x2a>
		__ASSERT_NO_MSG(false);
		return ret;
	}

	if (ret < (int)sizeof(magic)) {
2003d9f6:	47b1                	li	a5,12
2003d9f8:	00a7c763          	blt	a5,a0,2003da06 <initialize_tx_with_sid_disabled+0x32>
		__ASSERT_NO_MSG(ret == sizeof(magic));
		return -EINVAL;
2003d9fc:	5529                	li	a0,-22
	}

	return 0;
}
2003d9fe:	40a2                	lw	ra,8(sp)
2003da00:	4412                	lw	s0,4(sp)
2003da02:	0131                	addi	sp,sp,12
2003da04:	8082                	ret
	return 0;
2003da06:	4501                	li	a0,0
2003da08:	bfdd                	j	2003d9fe <initialize_tx_with_sid_disabled+0x2a>

2003da0a <mbox_callback>:
}
#endif /* def CONFIG_MULTITHREADING */

static void mbox_callback(const struct device *instance, uint32_t channel,
			  void *user_data, struct mbox_msg *msg_data)
{
2003da0a:	f6410113          	addi	sp,sp,-156
	atomic_t state = atomic_get(&dev_data->state);
2003da0e:	01860793          	addi	a5,a2,24
{
2003da12:	cb22                	sw	s0,148(sp)
2003da14:	cd06                	sw	ra,152(sp)
2003da16:	c926                	sw	s1,144(sp)
2003da18:	8432                	mv	s0,a2
	atomic_t state = atomic_get(&dev_data->state);
2003da1a:	c03e                	sw	a5,0(sp)
2003da1c:	4502                	lw	a0,0(sp)
2003da1e:	2d5000ef          	jal	ra,2003e4f2 <atomic_get>
	switch (state) {
2003da22:	470d                	li	a4,3
	atomic_t state = atomic_get(&dev_data->state);
2003da24:	84aa                	mv	s1,a0
	switch (state) {
2003da26:	08e50963          	beq	a0,a4,2003dab8 <mbox_callback+0xae>
2003da2a:	00a74e63          	blt	a4,a0,2003da46 <mbox_callback+0x3c>
2003da2e:	4705                	li	a4,1
2003da30:	02e50063          	beq	a0,a4,2003da50 <mbox_callback+0x46>
2003da34:	4709                	li	a4,2
2003da36:	0ce50c63          	beq	a0,a4,2003db0e <mbox_callback+0x104>
#else
	do {
		rerun = callback_process(dev_data);
	} while (rerun);
#endif
}
2003da3a:	40ea                	lw	ra,152(sp)
2003da3c:	445a                	lw	s0,148(sp)
2003da3e:	44ca                	lw	s1,144(sp)
2003da40:	09c10113          	addi	sp,sp,156
2003da44:	8082                	ret
	switch (state) {
2003da46:	ffb50713          	addi	a4,a0,-5
2003da4a:	4685                	li	a3,1
2003da4c:	fee6e7e3          	bltu	a3,a4,2003da3a <mbox_callback+0x30>
	return pbuf_read(dev_data->rx_pb, NULL, 0);
2003da50:	4048                	lw	a0,4(s0)
2003da52:	4601                	li	a2,0
2003da54:	4581                	li	a1,0
2003da56:	2381                	jal	2003df96 <pbuf_read>
		if (len_available > 0 && sizeof(rx_buffer) >= len_available) {
2003da58:	fff50793          	addi	a5,a0,-1
2003da5c:	c23e                	sw	a5,4(sp)
2003da5e:	07f00713          	li	a4,127
2003da62:	12f76e63          	bltu	a4,a5,2003db9e <mbox_callback+0x194>
			len = pbuf_read(dev_data->rx_pb, rx_buffer, sizeof(rx_buffer));
2003da66:	4048                	lw	a0,4(s0)
2003da68:	080c                	addi	a1,sp,16
2003da6a:	08000613          	li	a2,128
2003da6e:	2325                	jal	2003df96 <pbuf_read>
		if (state == ICMSG_STATE_CONNECTED_SID_ENABLED &&
2003da70:	4719                	li	a4,6
			len = pbuf_read(dev_data->rx_pb, rx_buffer, sizeof(rx_buffer));
2003da72:	85aa                	mv	a1,a0
		if (state == ICMSG_STATE_CONNECTED_SID_ENABLED &&
2003da74:	12e48963          	beq	s1,a4,2003dba6 <mbox_callback+0x19c>
		if (state != ICMSG_STATE_INITIALIZING_SID_DISABLED || !UNBOUND_DISABLED) {
2003da78:	4705                	li	a4,1
2003da7a:	14e49f63          	bne	s1,a4,2003dbd8 <mbox_callback+0x1ce>
			bool endpoint_invalid = (len < sizeof(magic) ||
2003da7e:	47b1                	li	a5,12
2003da80:	faa7fde3          	bgeu	a5,a0,2003da3a <mbox_callback+0x30>
						memcmp(magic, rx_buffer, sizeof(magic)));
2003da84:	2003e537          	lui	a0,0x2003e
2003da88:	4635                	li	a2,13
2003da8a:	080c                	addi	a1,sp,16
2003da8c:	6e450513          	addi	a0,a0,1764 # 2003e6e4 <magic>
2003da90:	2c5000ef          	jal	ra,2003e554 <memcmp>
			bool endpoint_invalid = (len < sizeof(magic) ||
2003da94:	f15d                	bnez	a0,2003da3a <mbox_callback+0x30>
			if (dev_data->cb->bound) {
2003da96:	441c                	lw	a5,8(s0)
2003da98:	439c                	lw	a5,0(a5)
2003da9a:	c399                	beqz	a5,2003daa0 <mbox_callback+0x96>
				dev_data->cb->bound(dev_data->ctx);
2003da9c:	4448                	lw	a0,12(s0)
2003da9e:	9782                	jalr	a5
			atomic_set(&dev_data->state, ICMSG_STATE_CONNECTED_SID_DISABLED);
2003daa0:	4502                	lw	a0,0(sp)
2003daa2:	4595                	li	a1,5
2003daa4:	3f19                	jal	2003d9ba <atomic_set>
	return pbuf_read(dev_data->rx_pb, NULL, 0);
2003daa6:	4048                	lw	a0,4(s0)
2003daa8:	4601                	li	a2,0
2003daaa:	4581                	li	a1,0
2003daac:	21ed                	jal	2003df96 <pbuf_read>
		rerun = (data_available(dev_data) > 0);
2003daae:	00a034b3          	snez	s1,a0
		(void)mbox_send_dt(&dev_data->cfg->mbox_tx, NULL);
2003dab2:	4808                	lw	a0,16(s0)
2003dab4:	3729                	jal	2003d9be <mbox_send_dt.constprop.0>
2003dab6:	aa15                	j	2003dbea <mbox_callback+0x1e0>
		ret = pbuf_get_initial_buf(dev_data->rx_pb, &magic_buf, &magic_len);
2003dab8:	4048                	lw	a0,4(s0)
2003daba:	00e10613          	addi	a2,sp,14
2003dabe:	080c                	addi	a1,sp,16
2003dac0:	29a5                	jal	2003df38 <pbuf_get_initial_buf>
		if (ret == 0 && magic_len == sizeof(magic) &&
2003dac2:	e531                	bnez	a0,2003db0e <mbox_callback+0x104>
2003dac4:	00e15703          	lhu	a4,14(sp)
2003dac8:	47b5                	li	a5,13
2003daca:	04f71263          	bne	a4,a5,2003db0e <mbox_callback+0x104>
		    memcmp((void *)magic_buf, magic, sizeof(magic)) == 0) {
2003dace:	4542                	lw	a0,16(sp)
2003dad0:	2003e5b7          	lui	a1,0x2003e
2003dad4:	4635                	li	a2,13
2003dad6:	6e458593          	addi	a1,a1,1764 # 2003e6e4 <magic>
2003dada:	27b000ef          	jal	ra,2003e554 <memcmp>
		if (ret == 0 && magic_len == sizeof(magic) &&
2003dade:	e905                	bnez	a0,2003db0e <mbox_callback+0x104>
			ret = initialize_tx_with_sid_disabled(dev_data);
2003dae0:	8522                	mv	a0,s0
2003dae2:	3dcd                	jal	2003d9d4 <initialize_tx_with_sid_disabled>
			if (ret < 0) {
2003dae4:	00055f63          	bgez	a0,2003db02 <mbox_callback+0xf8>
				if (dev_data->cb->error) {
2003dae8:	441c                	lw	a5,8(s0)
2003daea:	47dc                	lw	a5,12(a5)
2003daec:	c799                	beqz	a5,2003dafa <mbox_callback+0xf0>
					dev_data->cb->error("Incorrect Tx configuration",
2003daee:	444c                	lw	a1,12(s0)
2003daf0:	2003e537          	lui	a0,0x2003e
2003daf4:	6c850513          	addi	a0,a0,1736 # 2003e6c8 <backend_ops+0x2c>
2003daf8:	9782                	jalr	a5
				atomic_set(&dev_data->state, ICMSG_STATE_OFF);
2003dafa:	4502                	lw	a0,0(sp)
2003dafc:	4581                	li	a1,0
2003dafe:	3d75                	jal	2003d9ba <atomic_set>
	} while (rerun);
2003db00:	bf2d                	j	2003da3a <mbox_callback+0x30>
			atomic_set(&dev_data->state, ICMSG_STATE_INITIALIZING_SID_DISABLED);
2003db02:	4502                	lw	a0,0(sp)
2003db04:	4585                	li	a1,1
2003db06:	3d55                	jal	2003d9ba <atomic_set>
		(void)mbox_send_dt(&dev_data->cfg->mbox_tx, NULL);
2003db08:	4808                	lw	a0,16(s0)
2003db0a:	3d55                	jal	2003d9be <mbox_send_dt.constprop.0>
	} while (rerun);
2003db0c:	bf01                	j	2003da1c <mbox_callback+0x12>
		uint32_t tx_handshake = pbuf_handshake_read(dev_data->tx_pb);
2003db0e:	4008                	lw	a0,0(s0)
2003db10:	2385                	jal	2003e070 <pbuf_handshake_read>
		if (remote_sid_req != dev_data->remote_sid && remote_sid_req != SID_DISCONNECTED) {
2003db12:	01445703          	lhu	a4,20(s0)
		uint32_t remote_sid_req = REMOTE_SID_REQ_FROM_TX(tx_handshake);
2003db16:	01051693          	slli	a3,a0,0x10
2003db1a:	82c1                	srli	a3,a3,0x10
		uint32_t local_sid_ack = LOCAL_SID_ACK_FROM_TX(tx_handshake);
2003db1c:	01055493          	srli	s1,a0,0x10
		if (remote_sid_req != dev_data->remote_sid && remote_sid_req != SID_DISCONNECTED) {
2003db20:	06e68163          	beq	a3,a4,2003db82 <mbox_callback+0x178>
	bool notify_remote = false;
2003db24:	4701                	li	a4,0
		if (remote_sid_req != dev_data->remote_sid && remote_sid_req != SID_DISCONNECTED) {
2003db26:	c2a9                	beqz	a3,2003db68 <mbox_callback+0x15e>
2003db28:	c22a                	sw	a0,4(sp)
			ret = pbuf_tx_init(dev_data->tx_pb);
2003db2a:	4008                	lw	a0,0(s0)
2003db2c:	2ce9                	jal	2003de06 <pbuf_tx_init>
			if (ret < 0) {
2003db2e:	4792                	lw	a5,4(sp)
2003db30:	02055363          	bgez	a0,2003db56 <mbox_callback+0x14c>
				if (dev_data->cb->error) {
2003db34:	441c                	lw	a5,8(s0)
2003db36:	47dc                	lw	a5,12(a5)
2003db38:	c799                	beqz	a5,2003db46 <mbox_callback+0x13c>
					dev_data->cb->error("Incorrect Tx configuration",
2003db3a:	444c                	lw	a1,12(s0)
2003db3c:	2003e537          	lui	a0,0x2003e
2003db40:	6c850513          	addi	a0,a0,1736 # 2003e6c8 <backend_ops+0x2c>
2003db44:	9782                	jalr	a5
}
2003db46:	445a                	lw	s0,148(sp)
				atomic_set(&dev_data->state, ICMSG_STATE_DISCONNECTED);
2003db48:	4502                	lw	a0,0(sp)
}
2003db4a:	40ea                	lw	ra,152(sp)
2003db4c:	44ca                	lw	s1,144(sp)
				atomic_set(&dev_data->state, ICMSG_STATE_DISCONNECTED);
2003db4e:	4591                	li	a1,4
}
2003db50:	09c10113          	addi	sp,sp,156
				atomic_set(&dev_data->state, ICMSG_STATE_DISCONNECTED);
2003db54:	b59d                	j	2003d9ba <atomic_set>
				MAKE_RX_HANDSHAKE(dev_data->local_sid, dev_data->remote_sid));
2003db56:	01645583          	lhu	a1,22(s0)
			pbuf_handshake_write(dev_data->rx_pb,
2003db5a:	4048                	lw	a0,4(s0)
			dev_data->remote_sid = remote_sid_req;
2003db5c:	00f41a23          	sh	a5,20(s0)
				MAKE_RX_HANDSHAKE(dev_data->local_sid, dev_data->remote_sid));
2003db60:	07c2                	slli	a5,a5,0x10
			pbuf_handshake_write(dev_data->rx_pb,
2003db62:	8ddd                	or	a1,a1,a5
2003db64:	2b21                	jal	2003e07c <pbuf_handshake_write>
			notify_remote = true;
2003db66:	4705                	li	a4,1
		if (local_sid_ack == dev_data->local_sid &&
2003db68:	01645783          	lhu	a5,22(s0)
2003db6c:	00f48d63          	beq	s1,a5,2003db86 <mbox_callback+0x17c>
	if (notify_remote) {
2003db70:	ec0705e3          	beqz	a4,2003da3a <mbox_callback+0x30>
		(void)mbox_send_dt(&dev_data->cfg->mbox_tx, NULL);
2003db74:	4808                	lw	a0,16(s0)
}
2003db76:	445a                	lw	s0,148(sp)
2003db78:	40ea                	lw	ra,152(sp)
2003db7a:	44ca                	lw	s1,144(sp)
2003db7c:	09c10113          	addi	sp,sp,156
		(void)mbox_send_dt(&dev_data->cfg->mbox_tx, NULL);
2003db80:	bd3d                	j	2003d9be <mbox_send_dt.constprop.0>
	bool notify_remote = false;
2003db82:	4701                	li	a4,0
2003db84:	b7d5                	j	2003db68 <mbox_callback+0x15e>
		if (local_sid_ack == dev_data->local_sid &&
2003db86:	01445783          	lhu	a5,20(s0)
2003db8a:	d3fd                	beqz	a5,2003db70 <mbox_callback+0x166>
			atomic_set(&dev_data->state, ICMSG_STATE_CONNECTED_SID_ENABLED);
2003db8c:	4502                	lw	a0,0(sp)
2003db8e:	4599                	li	a1,6
2003db90:	352d                	jal	2003d9ba <atomic_set>
			if (dev_data->cb->bound) {
2003db92:	441c                	lw	a5,8(s0)
2003db94:	439c                	lw	a5,0(a5)
2003db96:	dbad                	beqz	a5,2003db08 <mbox_callback+0xfe>
				dev_data->cb->bound(dev_data->ctx);
2003db98:	4448                	lw	a0,12(s0)
2003db9a:	9782                	jalr	a5
2003db9c:	b7b5                	j	2003db08 <mbox_callback+0xfe>
		if (state == ICMSG_STATE_CONNECTED_SID_ENABLED &&
2003db9e:	4719                	li	a4,6
2003dba0:	e8e49de3          	bne	s1,a4,2003da3a <mbox_callback+0x30>
	uint32_t len = 0;
2003dba4:	4581                	li	a1,0
			uint32_t remote_sid_req = REMOTE_SID_REQ_FROM_TX(
2003dba6:	4008                	lw	a0,0(s0)
2003dba8:	c42e                	sw	a1,8(sp)
2003dbaa:	21d9                	jal	2003e070 <pbuf_handshake_read>
			if (remote_sid_req != dev_data->remote_sid) {
2003dbac:	01445783          	lhu	a5,20(s0)
			uint32_t remote_sid_req = REMOTE_SID_REQ_FROM_TX(
2003dbb0:	0542                	slli	a0,a0,0x10
2003dbb2:	8141                	srli	a0,a0,0x10
			if (remote_sid_req != dev_data->remote_sid) {
2003dbb4:	45a2                	lw	a1,8(sp)
2003dbb6:	00f50c63          	beq	a0,a5,2003dbce <mbox_callback+0x1c4>
				atomic_set(&dev_data->state, ICMSG_STATE_DISCONNECTED);
2003dbba:	4502                	lw	a0,0(sp)
2003dbbc:	4591                	li	a1,4
2003dbbe:	3bf5                	jal	2003d9ba <atomic_set>
				if (dev_data->cb->unbound) {
2003dbc0:	441c                	lw	a5,8(s0)
2003dbc2:	43dc                	lw	a5,4(a5)
2003dbc4:	e6078be3          	beqz	a5,2003da3a <mbox_callback+0x30>
					dev_data->cb->unbound(dev_data->ctx);
2003dbc8:	4448                	lw	a0,12(s0)
2003dbca:	9782                	jalr	a5
	} while (rerun);
2003dbcc:	b5bd                	j	2003da3a <mbox_callback+0x30>
		if (len_available == 0) {
2003dbce:	4712                	lw	a4,4(sp)
2003dbd0:	07f00793          	li	a5,127
2003dbd4:	e6e7e3e3          	bltu	a5,a4,2003da3a <mbox_callback+0x30>
			if (dev_data->cb->received) {
2003dbd8:	441c                	lw	a5,8(s0)
2003dbda:	479c                	lw	a5,8(a5)
2003dbdc:	eb91                	bnez	a5,2003dbf0 <mbox_callback+0x1e6>
	return pbuf_read(dev_data->rx_pb, NULL, 0);
2003dbde:	4048                	lw	a0,4(s0)
2003dbe0:	4601                	li	a2,0
2003dbe2:	4581                	li	a1,0
2003dbe4:	2e4d                	jal	2003df96 <pbuf_read>
		rerun = (data_available(dev_data) > 0);
2003dbe6:	00a034b3          	snez	s1,a0
	} while (rerun);
2003dbea:	e20499e3          	bnez	s1,2003da1c <mbox_callback+0x12>
2003dbee:	b5b1                	j	2003da3a <mbox_callback+0x30>
				dev_data->cb->received(rx_buffer, len, dev_data->ctx);
2003dbf0:	4450                	lw	a2,12(s0)
2003dbf2:	0808                	addi	a0,sp,16
2003dbf4:	9782                	jalr	a5
2003dbf6:	b7e5                	j	2003dbde <mbox_callback+0x1d4>

2003dbf8 <icmsg_open>:
}

int icmsg_open(const struct icmsg_config_t *conf,
	       struct icmsg_data_t *dev_data,
	       const struct ipc_service_cb *cb, void *ctx)
{
2003dbf8:	1111                	addi	sp,sp,-28
2003dbfa:	ca22                	sw	s0,20(sp)
2003dbfc:	c826                	sw	s1,16(sp)
2003dbfe:	cc06                	sw	ra,24(sp)
2003dc00:	842e                	mv	s0,a1
	__ASSERT(conf->unbound_mode != ICMSG_UNBOUND_MODE_ENABLE || UNBOUND_ENABLED,
		 "Unbound mode \"enabled\" is was forbidden in Kconfig.");
	__ASSERT(conf->unbound_mode != ICMSG_UNBOUND_MODE_DETECT || UNBOUND_DETECT,
		 "Unbound mode \"detect\" is was forbidden in Kconfig.");

	if (conf->unbound_mode == ICMSG_UNBOUND_MODE_DISABLE ||
2003dc02:	490c                	lw	a1,16(a0)
	    !(UNBOUND_ENABLED || UNBOUND_DETECT)) {
		if (!atomic_cas(&dev_data->state, ICMSG_STATE_OFF,
2003dc04:	01840793          	addi	a5,s0,24
2003dc08:	c23e                	sw	a5,4(sp)
{
2003dc0a:	c432                	sw	a2,8(sp)
2003dc0c:	c636                	sw	a3,12(sp)
	if (conf->unbound_mode == ICMSG_UNBOUND_MODE_DISABLE ||
2003dc0e:	4785                	li	a5,1
{
2003dc10:	84aa                	mv	s1,a0
	if (conf->unbound_mode == ICMSG_UNBOUND_MODE_DISABLE ||
2003dc12:	06f59e63          	bne	a1,a5,2003dc8e <icmsg_open+0x96>
	return z_impl_atomic_cas(target, old_value, new_value);
2003dc16:	4605                	li	a2,1
2003dc18:	4581                	li	a1,0
2003dc1a:	01840513          	addi	a0,s0,24
2003dc1e:	0bb000ef          	jal	ra,2003e4d8 <z_impl_atomic_cas>
				ICMSG_STATE_INITIALIZING_SID_DISABLED)) {
			/* Already opened. */
			return -EALREADY;
		}
		old_state = ICMSG_STATE_OFF;
2003dc22:	c002                	sw	zero,0(sp)
			return -EALREADY;
2003dc24:	f8800793          	li	a5,-120
		if (!atomic_cas(&dev_data->state, ICMSG_STATE_OFF,
2003dc28:	cd29                	beqz	a0,2003dc82 <icmsg_open+0x8a>
	} else {
		/* Unbound mode has the same values as ICMSG_STATE_INITIALIZING_* */
		old_state = atomic_set(&dev_data->state, conf->unbound_mode);
	}

	dev_data->cb = cb;
2003dc2a:	47a2                	lw	a5,8(sp)

#ifdef CONFIG_IPC_SERVICE_ICMSG_SHMEM_ACCESS_SYNC
	k_mutex_init(&dev_data->tx_lock);
#endif

	ret = pbuf_rx_init(dev_data->rx_pb);
2003dc2c:	4048                	lw	a0,4(s0)
	dev_data->cfg = conf;
2003dc2e:	c804                	sw	s1,16(s0)
	dev_data->cb = cb;
2003dc30:	c41c                	sw	a5,8(s0)
	dev_data->ctx = ctx;
2003dc32:	47b2                	lw	a5,12(sp)
2003dc34:	c45c                	sw	a5,12(s0)
	ret = pbuf_rx_init(dev_data->rx_pb);
2003dc36:	2429                	jal	2003de40 <pbuf_rx_init>
2003dc38:	87aa                	mv	a5,a0

	if (ret < 0) {
2003dc3a:	06054463          	bltz	a0,2003dca2 <icmsg_open+0xaa>
		__ASSERT(false, "Incorrect Rx configuration");
		goto cleanup_and_exit;
	}

	if (conf->unbound_mode != ICMSG_UNBOUND_MODE_DISABLE &&
2003dc3e:	4898                	lw	a4,16(s1)
2003dc40:	4785                	li	a5,1
2003dc42:	04f70b63          	beq	a4,a5,2003dc98 <icmsg_open+0xa0>
	    (UNBOUND_ENABLED || UNBOUND_DETECT)) {
		/* Increment local session id without conflicts with forbidden values. */
		uint32_t local_sid_ack =
			LOCAL_SID_ACK_FROM_TX(pbuf_handshake_read(dev_data->tx_pb));
2003dc46:	4008                	lw	a0,0(s0)
2003dc48:	2125                	jal	2003e070 <pbuf_handshake_read>
		uint32_t local_sid_ack =
2003dc4a:	01055793          	srli	a5,a0,0x10
		dev_data->local_sid =
			LOCAL_SID_REQ_FROM_RX(pbuf_handshake_read(dev_data->tx_pb));
2003dc4e:	4008                	lw	a0,0(s0)
		uint32_t local_sid_ack =
2003dc50:	c43e                	sw	a5,8(sp)
			LOCAL_SID_REQ_FROM_RX(pbuf_handshake_read(dev_data->tx_pb));
2003dc52:	2939                	jal	2003e070 <pbuf_handshake_read>
		dev_data->remote_sid = SID_DISCONNECTED;
2003dc54:	47a2                	lw	a5,8(sp)
		dev_data->local_sid =
2003dc56:	01051593          	slli	a1,a0,0x10
2003dc5a:	81c1                	srli	a1,a1,0x10
		dev_data->remote_sid = SID_DISCONNECTED;
2003dc5c:	00041a23          	sh	zero,20(s0)
		do {
			dev_data->local_sid = (dev_data->local_sid + 1) & 0xFFFF;
2003dc60:	0585                	addi	a1,a1,1
2003dc62:	05c2                	slli	a1,a1,0x10
2003dc64:	81c1                	srli	a1,a1,0x10
		} while (dev_data->local_sid == local_sid_ack ||
2003dc66:	fef58de3          	beq	a1,a5,2003dc60 <icmsg_open+0x68>
2003dc6a:	d9fd                	beqz	a1,2003dc60 <icmsg_open+0x68>
			 dev_data->local_sid == SID_DISCONNECTED);
		/* Write local session id request without remote acknowledge */
		pbuf_handshake_write(dev_data->rx_pb,
2003dc6c:	4048                	lw	a0,4(s0)
2003dc6e:	00b41b23          	sh	a1,22(s0)
2003dc72:	2129                	jal	2003e07c <pbuf_handshake_write>
		if (ret < 0) {
			goto cleanup_and_exit;
		}
	}

	if (old_state == ICMSG_STATE_OFF && (UNBOUND_ENABLED || UNBOUND_DETECT)) {
2003dc74:	4782                	lw	a5,0(sp)
2003dc76:	cf85                	beqz	a5,2003dcae <icmsg_open+0xb6>
	/* We need to send a notification to remote, it may not be delivered
	 * since it may be uninitialized yet, but when it finishes the initialization
	 * we get a notification from it. We need to send this notification in callback
	 * again to make sure that it arrived.
	 */
	ret = mbox_send_dt(&conf->mbox_tx, NULL);
2003dc78:	8526                	mv	a0,s1
2003dc7a:	3391                	jal	2003d9be <mbox_send_dt.constprop.0>
2003dc7c:	87aa                	mv	a5,a0

	if (ret < 0) {
2003dc7e:	02054263          	bltz	a0,2003dca2 <icmsg_open+0xaa>
	return ret;

cleanup_and_exit:
	atomic_set(&dev_data->state, ICMSG_STATE_OFF);
	return ret;
}
2003dc82:	40e2                	lw	ra,24(sp)
2003dc84:	4452                	lw	s0,20(sp)
2003dc86:	44c2                	lw	s1,16(sp)
2003dc88:	853e                	mv	a0,a5
2003dc8a:	0171                	addi	sp,sp,28
2003dc8c:	8082                	ret
		old_state = atomic_set(&dev_data->state, conf->unbound_mode);
2003dc8e:	01840513          	addi	a0,s0,24
2003dc92:	3325                	jal	2003d9ba <atomic_set>
2003dc94:	c02a                	sw	a0,0(sp)
2003dc96:	bf51                	j	2003dc2a <icmsg_open+0x32>
		ret = initialize_tx_with_sid_disabled(dev_data);
2003dc98:	8522                	mv	a0,s0
2003dc9a:	3b2d                	jal	2003d9d4 <initialize_tx_with_sid_disabled>
2003dc9c:	87aa                	mv	a5,a0
		if (ret < 0) {
2003dc9e:	fc055be3          	bgez	a0,2003dc74 <icmsg_open+0x7c>
	atomic_set(&dev_data->state, ICMSG_STATE_OFF);
2003dca2:	4512                	lw	a0,4(sp)
2003dca4:	4581                	li	a1,0
2003dca6:	c03e                	sw	a5,0(sp)
2003dca8:	3b09                	jal	2003d9ba <atomic_set>
2003dcaa:	4782                	lw	a5,0(sp)
	return ret;
2003dcac:	bfd9                	j	2003dc82 <icmsg_open+0x8a>
 * @return See return values for mbox_register_callback()
 */
static inline int mbox_register_callback_dt(const struct mbox_dt_spec *spec,
					    mbox_callback_t cb, void *user_data)
{
	return mbox_register_callback(spec->dev, spec->channel_id, cb,
2003dcae:	4488                	lw	a0,8(s1)
2003dcb0:	44cc                	lw	a1,12(s1)
	if (api->register_callback == NULL) {
2003dcb2:	451c                	lw	a5,8(a0)
2003dcb4:	43dc                	lw	a5,4(a5)
2003dcb6:	e781                	bnez	a5,2003dcbe <icmsg_open+0xc6>
		return -ENOSYS;
2003dcb8:	fa800793          	li	a5,-88
2003dcbc:	b7dd                	j	2003dca2 <icmsg_open+0xaa>
	return api->register_callback(dev, channel_id, cb, user_data);
2003dcbe:	2003e637          	lui	a2,0x2003e
2003dcc2:	86a2                	mv	a3,s0
2003dcc4:	a0a60613          	addi	a2,a2,-1526 # 2003da0a <mbox_callback>
2003dcc8:	9782                	jalr	a5
2003dcca:	87aa                	mv	a5,a0
	if (err != 0) {
2003dccc:	f979                	bnez	a0,2003dca2 <icmsg_open+0xaa>
 * @return See return values for mbox_set_enabled()
 */
static inline int mbox_set_enabled_dt(const struct mbox_dt_spec *spec,
				      bool enabled)
{
	return mbox_set_enabled(spec->dev, spec->channel_id, enabled);
2003dcce:	4488                	lw	a0,8(s1)
2003dcd0:	44cc                	lw	a1,12(s1)
	if (api->set_enabled == NULL) {
2003dcd2:	451c                	lw	a5,8(a0)
2003dcd4:	4b9c                	lw	a5,16(a5)
2003dcd6:	d3ed                	beqz	a5,2003dcb8 <icmsg_open+0xc0>
	return api->set_enabled(dev, channel_id, enabled);
2003dcd8:	4605                	li	a2,1
2003dcda:	9782                	jalr	a5
2003dcdc:	87aa                	mv	a5,a0
		if (ret) {
2003dcde:	dd49                	beqz	a0,2003dc78 <icmsg_open+0x80>
2003dce0:	b7c9                	j	2003dca2 <icmsg_open+0xaa>

2003dce2 <icmsg_close>:

int icmsg_close(const struct icmsg_config_t *conf,
		struct icmsg_data_t *dev_data)
{
2003dce2:	1151                	addi	sp,sp,-12
2003dce4:	c222                	sw	s0,4(sp)
2003dce6:	c026                	sw	s1,0(sp)
2003dce8:	c406                	sw	ra,8(sp)
	int ret = 0;
	enum icmsg_state old_state;

	if (conf->unbound_mode != ICMSG_UNBOUND_MODE_DISABLE &&
2003dcea:	4918                	lw	a4,16(a0)
2003dcec:	4785                	li	a5,1
{
2003dcee:	842a                	mv	s0,a0
2003dcf0:	84ae                	mv	s1,a1
	if (conf->unbound_mode != ICMSG_UNBOUND_MODE_DISABLE &&
2003dcf2:	00f70563          	beq	a4,a5,2003dcfc <icmsg_close+0x1a>
	    (UNBOUND_ENABLED || UNBOUND_DETECT)) {
		pbuf_handshake_write(dev_data->rx_pb,
2003dcf6:	40c8                	lw	a0,4(s1)
2003dcf8:	4581                	li	a1,0
2003dcfa:	2649                	jal	2003e07c <pbuf_handshake_write>
			MAKE_RX_HANDSHAKE(SID_DISCONNECTED, SID_DISCONNECTED));
	}

	(void)mbox_send_dt(&conf->mbox_tx, NULL);
2003dcfc:	8522                	mv	a0,s0
2003dcfe:	31c1                	jal	2003d9be <mbox_send_dt.constprop.0>

	old_state = atomic_set(&dev_data->state, ICMSG_STATE_OFF);
2003dd00:	4581                	li	a1,0
2003dd02:	01848513          	addi	a0,s1,24
2003dd06:	3955                	jal	2003d9ba <atomic_set>

	if (old_state != ICMSG_STATE_OFF) {
2003dd08:	c901                	beqz	a0,2003dd18 <icmsg_close+0x36>
	return mbox_set_enabled(spec->dev, spec->channel_id, enabled);
2003dd0a:	4408                	lw	a0,8(s0)
2003dd0c:	444c                	lw	a1,12(s0)
	if (api->set_enabled == NULL) {
2003dd0e:	451c                	lw	a5,8(a0)
2003dd10:	4b9c                	lw	a5,16(a5)
2003dd12:	eb81                	bnez	a5,2003dd22 <icmsg_close+0x40>
		return -ENOSYS;
2003dd14:	fa800513          	li	a0,-88
		ret = mbox_deinit(conf, dev_data);
	}

	return ret;
}
2003dd18:	40a2                	lw	ra,8(sp)
2003dd1a:	4412                	lw	s0,4(sp)
2003dd1c:	4482                	lw	s1,0(sp)
2003dd1e:	0131                	addi	sp,sp,12
2003dd20:	8082                	ret
	return api->set_enabled(dev, channel_id, enabled);
2003dd22:	4601                	li	a2,0
2003dd24:	9782                	jalr	a5
	if (err != 0) {
2003dd26:	f96d                	bnez	a0,2003dd18 <icmsg_close+0x36>
	return mbox_register_callback(spec->dev, spec->channel_id, cb,
2003dd28:	4408                	lw	a0,8(s0)
2003dd2a:	444c                	lw	a1,12(s0)
	if (api->register_callback == NULL) {
2003dd2c:	451c                	lw	a5,8(a0)
2003dd2e:	43dc                	lw	a5,4(a5)
2003dd30:	d3f5                	beqz	a5,2003dd14 <icmsg_close+0x32>
}
2003dd32:	4412                	lw	s0,4(sp)
2003dd34:	40a2                	lw	ra,8(sp)
2003dd36:	4482                	lw	s1,0(sp)
	return api->register_callback(dev, channel_id, cb, user_data);
2003dd38:	4681                	li	a3,0
2003dd3a:	4601                	li	a2,0
2003dd3c:	0131                	addi	sp,sp,12
2003dd3e:	8782                	jr	a5

2003dd40 <icmsg_send>:

int icmsg_send(const struct icmsg_config_t *conf,
	       struct icmsg_data_t *dev_data,
	       const void *msg, size_t len)
{
2003dd40:	1131                	addi	sp,sp,-20
2003dd42:	c02a                	sw	a0,0(sp)
	int ret;
	int write_ret;
	int release_ret;
	int sent_bytes;
	uint32_t state = atomic_get(&dev_data->state);
2003dd44:	01858513          	addi	a0,a1,24
{
2003dd48:	c622                	sw	s0,12(sp)
2003dd4a:	c426                	sw	s1,8(sp)
2003dd4c:	c232                	sw	a2,4(sp)
2003dd4e:	84ae                	mv	s1,a1
2003dd50:	c806                	sw	ra,16(sp)
2003dd52:	8436                	mv	s0,a3
	uint32_t state = atomic_get(&dev_data->state);
2003dd54:	79e000ef          	jal	ra,2003e4f2 <atomic_get>

	if (!is_endpoint_ready(state)) {
2003dd58:	4611                	li	a2,4
2003dd5a:	4592                	lw	a1,4(sp)
2003dd5c:	00a64c63          	blt	a2,a0,2003dd74 <icmsg_send+0x34>
2003dd60:	872a                	mv	a4,a0
		/* If instance was disconnected on the remote side, some threads may still
		 * don't know it yet and still may try to send messages.
		 */
		return (state == ICMSG_STATE_DISCONNECTED) ? len : -EBUSY;
2003dd62:	5541                	li	a0,-16
2003dd64:	00c71363          	bne	a4,a2,2003dd6a <icmsg_send+0x2a>
2003dd68:	8522                	mv	a0,s0
	if (ret) {
		return ret;
	}

	return sent_bytes;
}
2003dd6a:	40c2                	lw	ra,16(sp)
2003dd6c:	4432                	lw	s0,12(sp)
2003dd6e:	44a2                	lw	s1,8(sp)
2003dd70:	0151                	addi	sp,sp,20
2003dd72:	8082                	ret
		return -ENODATA;
2003dd74:	fc300513          	li	a0,-61
	if (len == 0) {
2003dd78:	d86d                	beqz	s0,2003dd6a <icmsg_send+0x2a>
	write_ret = pbuf_write(dev_data->tx_pb, msg, len);
2003dd7a:	4088                	lw	a0,0(s1)
2003dd7c:	01041613          	slli	a2,s0,0x10
2003dd80:	8241                	srli	a2,a2,0x10
2003dd82:	20c5                	jal	2003de62 <pbuf_write>
2003dd84:	84aa                	mv	s1,a0
	if (write_ret < 0) {
2003dd86:	00055463          	bgez	a0,2003dd8e <icmsg_send+0x4e>
		return -ENODATA;
2003dd8a:	8526                	mv	a0,s1
2003dd8c:	bff9                	j	2003dd6a <icmsg_send+0x2a>
		return -EBADMSG;
2003dd8e:	fb300513          	li	a0,-77
	} else if (write_ret < len) {
2003dd92:	fc84ece3          	bltu	s1,s0,2003dd6a <icmsg_send+0x2a>
	ret = mbox_send_dt(&conf->mbox_tx, NULL);
2003dd96:	4502                	lw	a0,0(sp)
2003dd98:	311d                	jal	2003d9be <mbox_send_dt.constprop.0>
	if (ret) {
2003dd9a:	d965                	beqz	a0,2003dd8a <icmsg_send+0x4a>
2003dd9c:	b7f9                	j	2003dd6a <icmsg_send+0x2a>

2003dd9e <validate_cfg>:
{
	return (idx >= len) ? (idx % len) : (idx);
}

static int validate_cfg(const struct pbuf_cfg *cfg)
{
2003dd9e:	87aa                	mv	a5,a0
	/* Validate pointers. */
	if (!cfg || !cfg->rd_idx_loc || !cfg->wr_idx_loc || !cfg->data_loc) {
2003dda0:	c12d                	beqz	a0,2003de02 <validate_cfg+0x64>
2003dda2:	4118                	lw	a4,0(a0)
		return -EINVAL;
2003dda4:	5529                	li	a0,-22
	if (!cfg || !cfg->rd_idx_loc || !cfg->wr_idx_loc || !cfg->data_loc) {
2003dda6:	cf39                	beqz	a4,2003de04 <validate_cfg+0x66>
2003dda8:	4794                	lw	a3,8(a5)
2003ddaa:	cea9                	beqz	a3,2003de04 <validate_cfg+0x66>
2003ddac:	0147a303          	lw	t1,20(a5)
2003ddb0:	04030a63          	beqz	t1,2003de04 <validate_cfg+0x66>
	}

	/* Validate pointer alignment. */
	if (!IS_PTR_ALIGNED_BYTES(cfg->rd_idx_loc, MAX(cfg->dcache_alignment, _PBUF_IDX_SIZE)) ||
2003ddb4:	47d0                	lw	a2,12(a5)
2003ddb6:	4591                	li	a1,4
2003ddb8:	00b67363          	bgeu	a2,a1,2003ddbe <validate_cfg+0x20>
2003ddbc:	4611                	li	a2,4
2003ddbe:	02c775b3          	remu	a1,a4,a2
		return -EINVAL;
2003ddc2:	5529                	li	a0,-22
	if (!IS_PTR_ALIGNED_BYTES(cfg->rd_idx_loc, MAX(cfg->dcache_alignment, _PBUF_IDX_SIZE)) ||
2003ddc4:	e1a1                	bnez	a1,2003de04 <validate_cfg+0x66>
	    !IS_PTR_ALIGNED_BYTES(cfg->wr_idx_loc, MAX(cfg->dcache_alignment, _PBUF_IDX_SIZE)) ||
2003ddc6:	02c6f5b3          	remu	a1,a3,a2
	if (!IS_PTR_ALIGNED_BYTES(cfg->rd_idx_loc, MAX(cfg->dcache_alignment, _PBUF_IDX_SIZE)) ||
2003ddca:	ed8d                	bnez	a1,2003de04 <validate_cfg+0x66>
	    !IS_PTR_ALIGNED_BYTES(cfg->handshake_loc, _PBUF_IDX_SIZE) ||
2003ddcc:	43cc                	lw	a1,4(a5)
2003ddce:	00b362b3          	or	t0,t1,a1
2003ddd2:	0032f293          	andi	t0,t0,3
2003ddd6:	02029763          	bnez	t0,2003de04 <validate_cfg+0x66>
	    !IS_PTR_ALIGNED_BYTES(cfg->data_loc, _PBUF_IDX_SIZE)) {
		return -EINVAL;
	}

	/* Validate len. */
	if (cfg->len < _PBUF_MIN_DATA_LEN || !IS_PTR_ALIGNED_BYTES(cfg->len, _PBUF_IDX_SIZE)) {
2003ddda:	4b9c                	lw	a5,16(a5)
2003dddc:	42ad                	li	t0,11
2003ddde:	02f2f363          	bgeu	t0,a5,2003de04 <validate_cfg+0x66>
2003dde2:	8b8d                	andi	a5,a5,3
2003dde4:	e385                	bnez	a5,2003de04 <validate_cfg+0x66>
		return -EINVAL;
	}

	/* Validate pointer values. */
	if (!(cfg->rd_idx_loc < cfg->wr_idx_loc) ||
2003dde6:	00d77f63          	bgeu	a4,a3,2003de04 <validate_cfg+0x66>
2003ddea:	c589                	beqz	a1,2003ddf4 <validate_cfg+0x56>
	    (cfg->handshake_loc && !(cfg->rd_idx_loc < cfg->handshake_loc)) ||
2003ddec:	00b77c63          	bgeu	a4,a1,2003de04 <validate_cfg+0x66>
2003ddf0:	00d5fa63          	bgeu	a1,a3,2003de04 <validate_cfg+0x66>
		return -EINVAL;
2003ddf4:	5529                	li	a0,-22
	    !(cfg->handshake_loc < cfg->wr_idx_loc) ||
2003ddf6:	0066f763          	bgeu	a3,t1,2003de04 <validate_cfg+0x66>
	    !((uint8_t *)cfg->wr_idx_loc < cfg->data_loc) ||
	    !(((uint8_t *)cfg->rd_idx_loc + MAX(_PBUF_IDX_SIZE, cfg->dcache_alignment)) ==
2003ddfa:	9732                	add	a4,a4,a2
	    (uint8_t *)cfg->wr_idx_loc)) {
		return -EINVAL;
	}

	return 0;
2003ddfc:	4501                	li	a0,0
	    !((uint8_t *)cfg->wr_idx_loc < cfg->data_loc) ||
2003ddfe:	00e68363          	beq	a3,a4,2003de04 <validate_cfg+0x66>
		return -EINVAL;
2003de02:	5529                	li	a0,-22
}
2003de04:	8082                	ret

2003de06 <pbuf_tx_init>:
	native_emb_addr_remap((void **)&pb->cfg->data_loc);
}
#endif

int pbuf_tx_init(struct pbuf *pb)
{
2003de06:	1151                	addi	sp,sp,-12
2003de08:	c222                	sw	s0,4(sp)
2003de0a:	c406                	sw	ra,8(sp)
2003de0c:	c026                	sw	s1,0(sp)
	if (validate_cfg(pb->cfg) != 0) {
2003de0e:	4104                	lw	s1,0(a0)
{
2003de10:	842a                	mv	s0,a0
	if (validate_cfg(pb->cfg) != 0) {
2003de12:	8526                	mv	a0,s1
2003de14:	3769                	jal	2003dd9e <validate_cfg>
2003de16:	e11d                	bnez	a0,2003de3c <pbuf_tx_init+0x36>
#if defined(CONFIG_ARCH_POSIX)
	pbuf_native_addr_remap(pb);
#endif

	/* Initialize local copy of indexes. */
	pb->data.wr_idx = 0;
2003de18:	00042223          	sw	zero,4(s0)
	pb->data.rd_idx = 0;
2003de1c:	00042423          	sw	zero,8(s0)

	/* Clear shared memory. */
	*(pb->cfg->wr_idx_loc) = pb->data.wr_idx;
2003de20:	449c                	lw	a5,8(s1)
2003de22:	4058                	lw	a4,4(s0)
2003de24:	c398                	sw	a4,0(a5)
	*(pb->cfg->rd_idx_loc) = pb->data.rd_idx;
2003de26:	401c                	lw	a5,0(s0)
2003de28:	4418                	lw	a4,8(s0)
2003de2a:	439c                	lw	a5,0(a5)
2003de2c:	c398                	sw	a4,0(a5)

	__sync_synchronize();
2003de2e:	0ff0000f          	fence
	/* Take care cache. */
	sys_cache_data_flush_range((void *)(pb->cfg->wr_idx_loc), sizeof(*(pb->cfg->wr_idx_loc)));
	sys_cache_data_flush_range((void *)(pb->cfg->rd_idx_loc), sizeof(*(pb->cfg->rd_idx_loc)));

	return 0;
}
2003de32:	40a2                	lw	ra,8(sp)
2003de34:	4412                	lw	s0,4(sp)
2003de36:	4482                	lw	s1,0(sp)
2003de38:	0131                	addi	sp,sp,12
2003de3a:	8082                	ret
		return -EINVAL;
2003de3c:	5529                	li	a0,-22
2003de3e:	bfd5                	j	2003de32 <pbuf_tx_init+0x2c>

2003de40 <pbuf_rx_init>:

int pbuf_rx_init(struct pbuf *pb)
{
2003de40:	1151                	addi	sp,sp,-12
2003de42:	c222                	sw	s0,4(sp)
2003de44:	c406                	sw	ra,8(sp)
2003de46:	842a                	mv	s0,a0
	if (validate_cfg(pb->cfg) != 0) {
2003de48:	4108                	lw	a0,0(a0)
2003de4a:	3f91                	jal	2003dd9e <validate_cfg>
2003de4c:	e909                	bnez	a0,2003de5e <pbuf_rx_init+0x1e>
#if defined(CONFIG_ARCH_POSIX)
	pbuf_native_addr_remap(pb);
#endif

	/* Initialize local copy of indexes. */
	pb->data.wr_idx = 0;
2003de4e:	00042223          	sw	zero,4(s0)
	pb->data.rd_idx = 0;
2003de52:	00042423          	sw	zero,8(s0)

	return 0;
}
2003de56:	40a2                	lw	ra,8(sp)
2003de58:	4412                	lw	s0,4(sp)
2003de5a:	0131                	addi	sp,sp,12
2003de5c:	8082                	ret
		return -EINVAL;
2003de5e:	5529                	li	a0,-22
2003de60:	bfdd                	j	2003de56 <pbuf_rx_init+0x16>

2003de62 <pbuf_write>:

int pbuf_write(struct pbuf *pb, const char *data, uint16_t len)
{
	if (pb == NULL || len == 0 || data == NULL) {
2003de62:	e909                	bnez	a0,2003de74 <pbuf_write+0x12>
		/* Incorrect call. */
		return -EINVAL;
2003de64:	5529                	li	a0,-22
	*(pb->cfg->wr_idx_loc) = wr_idx;
	__sync_synchronize();
	sys_cache_data_flush_range((void *)pb->cfg->wr_idx_loc, sizeof(*(pb->cfg->wr_idx_loc)));

	return len;
}
2003de66:	8082                	ret
		return -EINVAL;
2003de68:	5529                	li	a0,-22
}
2003de6a:	40f2                	lw	ra,28(sp)
2003de6c:	4462                	lw	s0,24(sp)
2003de6e:	44d2                	lw	s1,20(sp)
2003de70:	6105                	addi	sp,sp,32
2003de72:	8082                	ret
{
2003de74:	1101                	addi	sp,sp,-32
2003de76:	cc22                	sw	s0,24(sp)
2003de78:	ce06                	sw	ra,28(sp)
2003de7a:	ca26                	sw	s1,20(sp)
2003de7c:	8432                	mv	s0,a2
	if (pb == NULL || len == 0 || data == NULL) {
2003de7e:	d66d                	beqz	a2,2003de68 <pbuf_write+0x6>
2003de80:	d5e5                	beqz	a1,2003de68 <pbuf_write+0x6>
2003de82:	872a                	mv	a4,a0
	__sync_synchronize();
2003de84:	0ff0000f          	fence
	uint8_t *const data_loc = pb->cfg->data_loc;
2003de88:	411c                	lw	a5,0(a0)
2003de8a:	0147a303          	lw	t1,20(a5)
	const uint32_t blen = pb->cfg->len;
2003de8e:	4b94                	lw	a3,16(a5)
	uint32_t rd_idx = *(pb->cfg->rd_idx_loc);
2003de90:	439c                	lw	a5,0(a5)
2003de92:	4390                	lw	a2,0(a5)
	uint32_t wr_idx = pb->data.wr_idx;
2003de94:	4144                	lw	s1,4(a0)
	if (!IS_PTR_ALIGNED_BYTES(rd_idx, _PBUF_IDX_SIZE)) {
2003de96:	00367793          	andi	a5,a2,3
2003de9a:	f7f9                	bnez	a5,2003de68 <pbuf_write+0x6>
	return (rd_idx > wr_idx) ? (len - (rd_idx - wr_idx)) : (wr_idx - rd_idx);
2003de9c:	40c487b3          	sub	a5,s1,a2
2003dea0:	00c4f563          	bgeu	s1,a2,2003deaa <pbuf_write+0x48>
2003dea4:	009687b3          	add	a5,a3,s1
2003dea8:	8f91                	sub	a5,a5,a2
	uint32_t free_space = blen - idx_occupied(blen, wr_idx, rd_idx) - _PBUF_IDX_SIZE;
2003deaa:	ffc68613          	addi	a2,a3,-4
2003deae:	8e1d                	sub	a2,a2,a5
	uint32_t plen = len + PBUF_PACKET_LEN_SZ;
2003deb0:	00440793          	addi	a5,s0,4
		return -ENOMEM;
2003deb4:	5551                	li	a0,-12
	if (free_space < plen) {
2003deb6:	faf66ae3          	bltu	a2,a5,2003de6a <pbuf_write+0x8>
	*((uint32_t *)(&data_loc[wr_idx])) = 0;
2003deba:	009307b3          	add	a5,t1,s1
2003debe:	0007a023          	sw	zero,0(a5)
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
2003dec2:	00845613          	srli	a2,s0,0x8
2003dec6:	00c78023          	sb	a2,0(a5)
	dst[1] = val;
2003deca:	008780a3          	sb	s0,1(a5)
	__sync_synchronize();
2003dece:	0ff0000f          	fence
	wr_idx = idx_wrap(blen, wr_idx + PBUF_PACKET_LEN_SZ);
2003ded2:	0491                	addi	s1,s1,4
	return (idx >= len) ? (idx % len) : (idx);
2003ded4:	00d4e463          	bltu	s1,a3,2003dedc <pbuf_write+0x7a>
2003ded8:	02d4f4b3          	remu	s1,s1,a3
	uint32_t tail = MIN(len, blen - wr_idx);
2003dedc:	409687b3          	sub	a5,a3,s1
2003dee0:	00f47363          	bgeu	s0,a5,2003dee6 <pbuf_write+0x84>
2003dee4:	87a2                	mv	a5,s0
	memcpy(&data_loc[wr_idx], data, tail);
2003dee6:	863e                	mv	a2,a5
2003dee8:	00930533          	add	a0,t1,s1
2003deec:	c83a                	sw	a4,16(sp)
2003deee:	c636                	sw	a3,12(sp)
2003def0:	c43e                	sw	a5,8(sp)
2003def2:	c22e                	sw	a1,4(sp)
2003def4:	c01a                	sw	t1,0(sp)
2003def6:	2551                	jal	2003e57a <memcpy>
	if (len > tail) {
2003def8:	47a2                	lw	a5,8(sp)
2003defa:	4302                	lw	t1,0(sp)
2003defc:	4592                	lw	a1,4(sp)
2003defe:	46b2                	lw	a3,12(sp)
2003df00:	4742                	lw	a4,16(sp)
2003df02:	0087fb63          	bgeu	a5,s0,2003df18 <pbuf_write+0xb6>
		memcpy(&data_loc[0], data + tail, len - tail);
2003df06:	40f40633          	sub	a2,s0,a5
2003df0a:	95be                	add	a1,a1,a5
2003df0c:	851a                	mv	a0,t1
2003df0e:	c23a                	sw	a4,4(sp)
2003df10:	c036                	sw	a3,0(sp)
2003df12:	25a5                	jal	2003e57a <memcpy>
		union { uintptr_t x; void * val; } parm0 = { .val = addr };
		union { uintptr_t x; size_t val; } parm1 = { .val = size };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_SYS_CACHE_DATA_FLUSH_RANGE);
	}
#endif
	compiler_barrier();
2003df14:	4712                	lw	a4,4(sp)
2003df16:	4682                	lw	a3,0(sp)
	wr_idx = idx_wrap(blen, ROUND_UP(wr_idx + len, _PBUF_IDX_SIZE));
2003df18:	00340793          	addi	a5,s0,3
2003df1c:	97a6                	add	a5,a5,s1
2003df1e:	9bf1                	andi	a5,a5,-4
	return (idx >= len) ? (idx % len) : (idx);
2003df20:	00d7e463          	bltu	a5,a3,2003df28 <pbuf_write+0xc6>
2003df24:	02d7f7b3          	remu	a5,a5,a3
	pb->data.wr_idx = wr_idx;
2003df28:	c35c                	sw	a5,4(a4)
	*(pb->cfg->wr_idx_loc) = wr_idx;
2003df2a:	4318                	lw	a4,0(a4)
2003df2c:	4718                	lw	a4,8(a4)
2003df2e:	c31c                	sw	a5,0(a4)
	__sync_synchronize();
2003df30:	0ff0000f          	fence
	return len;
2003df34:	8522                	mv	a0,s0
2003df36:	bf15                	j	2003de6a <pbuf_write+0x8>

2003df38 <pbuf_get_initial_buf>:
int pbuf_get_initial_buf(struct pbuf *pb, volatile char **buf, uint16_t *len)
{
	uint32_t wr_idx;
	uint16_t plen;

	if (pb == NULL || pb->data.rd_idx != 0) {
2003df38:	e119                	bnez	a0,2003df3e <pbuf_get_initial_buf+0x6>
		/* Incorrect call. */
		return -EINVAL;
2003df3a:	5529                	li	a0,-22
2003df3c:	8082                	ret
	if (pb == NULL || pb->data.rd_idx != 0) {
2003df3e:	451c                	lw	a5,8(a0)
2003df40:	ffed                	bnez	a5,2003df3a <pbuf_get_initial_buf+0x2>
	}

	sys_cache_data_invd_range((void *)(pb->cfg->wr_idx_loc), sizeof(*(pb->cfg->wr_idx_loc)));
	__sync_synchronize();
2003df42:	0ff0000f          	fence

	wr_idx = *(pb->cfg->wr_idx_loc);
2003df46:	411c                	lw	a5,0(a0)
2003df48:	4798                	lw	a4,8(a5)
	if (wr_idx >= pb->cfg->len || wr_idx > 0xFFFF || wr_idx == 0) {
2003df4a:	4b9c                	lw	a5,16(a5)
	wr_idx = *(pb->cfg->wr_idx_loc);
2003df4c:	4314                	lw	a3,0(a4)
	if (wr_idx >= pb->cfg->len || wr_idx > 0xFFFF || wr_idx == 0) {
2003df4e:	fef6f6e3          	bgeu	a3,a5,2003df3a <pbuf_get_initial_buf+0x2>
2003df52:	67c1                	lui	a5,0x10
2003df54:	fff68713          	addi	a4,a3,-1
2003df58:	17f9                	addi	a5,a5,-2 # fffe <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x8ffe>
2003df5a:	fee7e0e3          	bltu	a5,a4,2003df3a <pbuf_get_initial_buf+0x2>
		/* Wrong index - probably pbuf was not initialized or message was not send yet. */
		return -EINVAL;
	}

	sys_cache_data_invd_range((void *)(pb->cfg->data_loc), PBUF_PACKET_LEN_SZ);
	__sync_synchronize();
2003df5e:	0ff0000f          	fence

	plen = sys_get_be16(&pb->cfg->data_loc[0]);
2003df62:	411c                	lw	a5,0(a0)
2003df64:	4bc8                	lw	a0,20(a5)
2003df66:	00154783          	lbu	a5,1(a0)
2003df6a:	00054703          	lbu	a4,0(a0)
2003df6e:	07a2                	slli	a5,a5,0x8
2003df70:	8fd9                	or	a5,a5,a4
2003df72:	00879713          	slli	a4,a5,0x8
2003df76:	83a1                	srli	a5,a5,0x8
2003df78:	8fd9                	or	a5,a5,a4
2003df7a:	07c2                	slli	a5,a5,0x10
2003df7c:	83c1                	srli	a5,a5,0x10

	if (plen + 4 > wr_idx) {
2003df7e:	00478713          	addi	a4,a5,4
2003df82:	fae6ece3          	bltu	a3,a4,2003df3a <pbuf_get_initial_buf+0x2>
		/* Wrong length - probably pbuf was not initialized or message was not send yet. */
		return -EINVAL;
	}

	*buf = &pb->cfg->data_loc[PBUF_PACKET_LEN_SZ];
2003df86:	0511                	addi	a0,a0,4
2003df88:	c188                	sw	a0,0(a1)
	*len = plen;
2003df8a:	00f61023          	sh	a5,0(a2)

	sys_cache_data_invd_range((void *)*buf, plen);
	__sync_synchronize();
2003df8e:	0ff0000f          	fence

	return 0;
2003df92:	4501                	li	a0,0
}
2003df94:	8082                	ret

2003df96 <pbuf_read>:

int pbuf_read(struct pbuf *pb, char *buf, uint16_t len)
{
	if (pb == NULL) {
2003df96:	e119                	bnez	a0,2003df9c <pbuf_read+0x6>
		/* Incorrect call. */
		return -EINVAL;
2003df98:	5529                	li	a0,-22
	*(pb->cfg->rd_idx_loc) = rd_idx;
	__sync_synchronize();
	sys_cache_data_flush_range((void *)pb->cfg->rd_idx_loc, sizeof(*(pb->cfg->rd_idx_loc)));

	return len;
}
2003df9a:	8082                	ret
{
2003df9c:	1121                	addi	sp,sp,-24
2003df9e:	c626                	sw	s1,12(sp)
2003dfa0:	ca06                	sw	ra,20(sp)
2003dfa2:	c822                	sw	s0,16(sp)
2003dfa4:	84aa                	mv	s1,a0
2003dfa6:	832e                	mv	t1,a1
	__sync_synchronize();
2003dfa8:	0ff0000f          	fence
	uint8_t *const data_loc = pb->cfg->data_loc;
2003dfac:	411c                	lw	a5,0(a0)
2003dfae:	4bcc                	lw	a1,20(a5)
	const uint32_t blen = pb->cfg->len;
2003dfb0:	4b94                	lw	a3,16(a5)
	uint32_t wr_idx = *(pb->cfg->wr_idx_loc);
2003dfb2:	479c                	lw	a5,8(a5)
2003dfb4:	0007a283          	lw	t0,0(a5)
	uint32_t rd_idx = pb->data.rd_idx;
2003dfb8:	451c                	lw	a5,8(a0)
		return -EINVAL;
2003dfba:	5529                	li	a0,-22
	if (!IS_PTR_ALIGNED_BYTES(wr_idx, _PBUF_IDX_SIZE)) {
2003dfbc:	0032f713          	andi	a4,t0,3
2003dfc0:	e70d                	bnez	a4,2003dfea <pbuf_read+0x54>
		return 0;
2003dfc2:	4501                	li	a0,0
	if (rd_idx == wr_idx) {
2003dfc4:	02f28363          	beq	t0,a5,2003dfea <pbuf_read+0x54>
	uint16_t plen = sys_get_be16(&data_loc[rd_idx]);
2003dfc8:	00f58733          	add	a4,a1,a5
2003dfcc:	00074503          	lbu	a0,0(a4)
2003dfd0:	00174703          	lbu	a4,1(a4)
2003dfd4:	0722                	slli	a4,a4,0x8
2003dfd6:	8f49                	or	a4,a4,a0
2003dfd8:	00871413          	slli	s0,a4,0x8
2003dfdc:	8321                	srli	a4,a4,0x8
2003dfde:	8c59                	or	s0,s0,a4
2003dfe0:	0442                	slli	s0,s0,0x10
2003dfe2:	8041                	srli	s0,s0,0x10
	if (!buf) {
2003dfe4:	00031863          	bnez	t1,2003dff4 <pbuf_read+0x5e>
	return len;
2003dfe8:	8522                	mv	a0,s0
}
2003dfea:	40d2                	lw	ra,20(sp)
2003dfec:	4442                	lw	s0,16(sp)
2003dfee:	44b2                	lw	s1,12(sp)
2003dff0:	0161                	addi	sp,sp,24
2003dff2:	8082                	ret
		return -ENOMEM;
2003dff4:	5551                	li	a0,-12
	if (plen > len) {
2003dff6:	fe866ae3          	bltu	a2,s0,2003dfea <pbuf_read+0x54>
	return (rd_idx > wr_idx) ? (len - (rd_idx - wr_idx)) : (wr_idx - rd_idx);
2003dffa:	40f28733          	sub	a4,t0,a5
2003dffe:	00f2f563          	bgeu	t0,a5,2003e008 <pbuf_read+0x72>
2003e002:	40f68733          	sub	a4,a3,a5
2003e006:	9716                	add	a4,a4,t0
	if (occupied_space < plen + PBUF_PACKET_LEN_SZ) {
2003e008:	00440613          	addi	a2,s0,4
		return -EAGAIN;
2003e00c:	5555                	li	a0,-11
	if (occupied_space < plen + PBUF_PACKET_LEN_SZ) {
2003e00e:	fcc76ee3          	bltu	a4,a2,2003dfea <pbuf_read+0x54>
	rd_idx = idx_wrap(blen, rd_idx + PBUF_PACKET_LEN_SZ);
2003e012:	00478713          	addi	a4,a5,4
	return (idx >= len) ? (idx % len) : (idx);
2003e016:	00d76463          	bltu	a4,a3,2003e01e <pbuf_read+0x88>
2003e01a:	02d77733          	remu	a4,a4,a3
	uint32_t tail = MIN(blen - rd_idx, len);
2003e01e:	40e687b3          	sub	a5,a3,a4
2003e022:	00f47363          	bgeu	s0,a5,2003e028 <pbuf_read+0x92>
2003e026:	87a2                	mv	a5,s0
2003e028:	c436                	sw	a3,8(sp)
	memcpy(buf, &data_loc[rd_idx], tail);
2003e02a:	863e                	mv	a2,a5
2003e02c:	95ba                	add	a1,a1,a4
2003e02e:	851a                	mv	a0,t1
2003e030:	c23e                	sw	a5,4(sp)
2003e032:	c03a                	sw	a4,0(sp)
2003e034:	2399                	jal	2003e57a <memcpy>
	if (len > tail) {
2003e036:	4792                	lw	a5,4(sp)
2003e038:	4702                	lw	a4,0(sp)
2003e03a:	46a2                	lw	a3,8(sp)
2003e03c:	0087fb63          	bgeu	a5,s0,2003e052 <pbuf_read+0xbc>
2003e040:	c236                	sw	a3,4(sp)
		memcpy(&buf[tail], &pb->cfg->data_loc[0], len - tail);
2003e042:	408c                	lw	a1,0(s1)
2003e044:	40f40633          	sub	a2,s0,a5
2003e048:	953e                	add	a0,a0,a5
2003e04a:	49cc                	lw	a1,20(a1)
2003e04c:	233d                	jal	2003e57a <memcpy>
2003e04e:	4692                	lw	a3,4(sp)
2003e050:	4702                	lw	a4,0(sp)
	rd_idx = idx_wrap(blen, ROUND_UP(rd_idx + len, _PBUF_IDX_SIZE));
2003e052:	00340793          	addi	a5,s0,3
2003e056:	97ba                	add	a5,a5,a4
2003e058:	9bf1                	andi	a5,a5,-4
	return (idx >= len) ? (idx % len) : (idx);
2003e05a:	00d7e463          	bltu	a5,a3,2003e062 <pbuf_read+0xcc>
2003e05e:	02d7f7b3          	remu	a5,a5,a3
	*(pb->cfg->rd_idx_loc) = rd_idx;
2003e062:	4098                	lw	a4,0(s1)
	pb->data.rd_idx = rd_idx;
2003e064:	c49c                	sw	a5,8(s1)
	*(pb->cfg->rd_idx_loc) = rd_idx;
2003e066:	4318                	lw	a4,0(a4)
2003e068:	c31c                	sw	a5,0(a4)
	__sync_synchronize();
2003e06a:	0ff0000f          	fence
2003e06e:	bfad                	j	2003dfe8 <pbuf_read+0x52>

2003e070 <pbuf_handshake_read>:

uint32_t pbuf_handshake_read(struct pbuf *pb)
{
	volatile uint32_t *ptr = pb->cfg->handshake_loc;
2003e070:	411c                	lw	a5,0(a0)
2003e072:	43dc                	lw	a5,4(a5)

	__ASSERT_NO_MSG(ptr);
	sys_cache_data_invd_range((void *)ptr, sizeof(*ptr));
	__sync_synchronize();
2003e074:	0ff0000f          	fence
	return *ptr;
2003e078:	4388                	lw	a0,0(a5)
}
2003e07a:	8082                	ret

2003e07c <pbuf_handshake_write>:

void pbuf_handshake_write(struct pbuf *pb, uint32_t value)
{
	volatile uint32_t *ptr = pb->cfg->handshake_loc;
2003e07c:	411c                	lw	a5,0(a0)
2003e07e:	43dc                	lw	a5,4(a5)

	__ASSERT_NO_MSG(ptr);
	*ptr = value;
2003e080:	c38c                	sw	a1,0(a5)
	__sync_synchronize();
2003e082:	0ff0000f          	fence
	sys_cache_data_flush_range((void *)ptr, sizeof(*ptr));
}
2003e086:	8082                	ret

2003e088 <sys_trace_idle>:

__weak void sys_trace_isr_exit(void) {}

__weak void sys_trace_isr_exit_to_scheduler(void) {}

__weak void sys_trace_idle(void)
2003e088:	8082                	ret

2003e08a <sys_trace_idle_exit>:
	if (IS_ENABLED(CONFIG_CPU_LOAD)) {
		cpu_load_on_enter_idle();
	}
}

__weak void sys_trace_idle_exit(void)
2003e08a:	8082                	ret

2003e08c <arch_early_memset>:
 * may override this with their own safe implementation.
 */
__boot_func
void __weak arch_early_memset(void *dst, int c, size_t n)
{
	(void) memset(dst, c, n);
2003e08c:	a311                	j	2003e590 <memset>

2003e08e <arch_bss_zero>:
{
	if (IS_ENABLED(CONFIG_SKIP_BSS_CLEAR)) {
		return;
	}

	arch_early_memset(__bss_start, 0, __bss_end - __bss_start);
2003e08e:	2003e537          	lui	a0,0x2003e
2003e092:	2003e7b7          	lui	a5,0x2003e
2003e096:	71450613          	addi	a2,a0,1812 # 2003e714 <cbck>
2003e09a:	7c078793          	addi	a5,a5,1984 # 2003e7c0 <z_interrupt_stacks>
2003e09e:	40c78633          	sub	a2,a5,a2
2003e0a2:	4581                	li	a1,0
2003e0a4:	71450513          	addi	a0,a0,1812
2003e0a8:	b7d5                	j	2003e08c <arch_early_memset>

2003e0aa <arch_cpu_idle>:
#include <zephyr/irq.h>
#include <zephyr/tracing/tracing.h>

#ifndef CONFIG_ARCH_HAS_CUSTOM_CPU_IDLE
void arch_cpu_idle(void)
{
2003e0aa:	1151                	addi	sp,sp,-12
2003e0ac:	c406                	sw	ra,8(sp)
	sys_trace_idle();
2003e0ae:	3fe9                	jal	2003e088 <sys_trace_idle>
	__asm__ volatile("wfi");
2003e0b0:	10500073          	wfi
	sys_trace_idle_exit();
2003e0b4:	3fd9                	jal	2003e08a <sys_trace_idle_exit>
static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
#ifdef CONFIG_RISCV_SOC_HAS_CUSTOM_IRQ_LOCK_OPS
	z_soc_irq_unlock(key);
#else
	__asm__ volatile ("csrs mstatus, %0"
2003e0b6:	47a1                	li	a5,8
2003e0b8:	3007a073          	csrs	mstatus,a5
	irq_unlock(MSTATUS_IEN);
}
2003e0bc:	40a2                	lw	ra,8(sp)
2003e0be:	0131                	addi	sp,sp,12
2003e0c0:	8082                	ret

2003e0c2 <z_riscv_get_sp_before_exc>:
		sp = esf->sp;
	}
#endif

	return sp;
}
2003e0c2:	04050513          	addi	a0,a0,64
2003e0c6:	8082                	ret

2003e0c8 <z_riscv_fatal_error_csf>:
	z_riscv_fatal_error_csf(reason, esf, NULL);
}

FUNC_NORETURN void z_riscv_fatal_error_csf(unsigned int reason, const struct arch_esf *esf,
					   const _callee_saved_t *csf)
{
2003e0c8:	1151                	addi	sp,sp,-12
2003e0ca:	c222                	sw	s0,4(sp)
2003e0cc:	c026                	sw	s1,0(sp)
2003e0ce:	842e                	mv	s0,a1
2003e0d0:	c406                	sw	ra,8(sp)
2003e0d2:	84aa                	mv	s1,a0
2003e0d4:	85b2                	mv	a1,a2
	unsigned long mcause;

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
2003e0d6:	342027f3          	csrr	a5,mcause
	EXCEPTION_DUMP(" mcause: %ld, %s", mcause, z_riscv_mcause_str(mcause));

#ifndef CONFIG_SOC_OPENISA_RV32M1
	unsigned long mtval;

	__asm__ volatile("csrr %0, mtval" : "=r" (mtval));
2003e0da:	343027f3          	csrr	a5,mtval
		EXCEPTION_DUMP("");
	}
#endif /* CONFIG_EXCEPTION_DEBUG */

#ifdef CONFIG_EXCEPTION_STACK_TRACE
	z_riscv_unwind_stack(esf, csf);
2003e0de:	8522                	mv	a0,s0
2003e0e0:	2291                	jal	2003e224 <z_riscv_unwind_stack>
#endif /* CONFIG_EXCEPTION_STACK_TRACE */

	z_fatal_error(reason, esf);
2003e0e2:	85a2                	mv	a1,s0
2003e0e4:	8526                	mv	a0,s1
2003e0e6:	2e35                	jal	2003e422 <z_fatal_error>

2003e0e8 <z_riscv_fatal_error>:
{
2003e0e8:	1151                	addi	sp,sp,-12
	z_riscv_fatal_error_csf(reason, esf, NULL);
2003e0ea:	4601                	li	a2,0
{
2003e0ec:	c406                	sw	ra,8(sp)
	z_riscv_fatal_error_csf(reason, esf, NULL);
2003e0ee:	3fe9                	jal	2003e0c8 <z_riscv_fatal_error_csf>

2003e0f0 <z_irq_spurious>:
#endif

LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

FUNC_NORETURN void z_irq_spurious(const void *unused)
{
2003e0f0:	1151                	addi	sp,sp,-12
2003e0f2:	c406                	sw	ra,8(sp)
#else
	unsigned long mcause;

	ARG_UNUSED(unused);

	mcause = csr_read(mcause);
2003e0f4:	342027f3          	csrr	a5,mcause
		const struct device *save_dev = riscv_plic_get_dev();

		LOG_ERR("PLIC interrupt line causing the IRQ: %d (%p)", save_irq, save_dev);
	}
#endif
	z_riscv_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
2003e0f8:	4581                	li	a1,0
2003e0fa:	4505                	li	a0,1
2003e0fc:	37f5                	jal	2003e0e8 <z_riscv_fatal_error>

2003e0fe <z_prep_c>:
 *
 * This routine prepares for the execution of and runs C code.
 */

FUNC_NORETURN void z_prep_c(void)
{
2003e0fe:	1151                	addi	sp,sp,-12
2003e100:	c406                	sw	ra,8(sp)
#if defined(CONFIG_SOC_PREP_HOOK)
	soc_prep_hook();
#endif

	arch_bss_zero();
2003e102:	3771                	jal	2003e08e <arch_bss_zero>
	soc_interrupt_init();
#endif
#if CONFIG_ARCH_CACHE
	arch_cache_init();
#endif
	z_cstart();
2003e104:	2e4d                	jal	2003e4b6 <z_cstart>

2003e106 <z_riscv_switch_to_main_no_multithreading>:

	ARG_UNUSED(p1);
	ARG_UNUSED(p2);
	ARG_UNUSED(p3);

	_kernel.cpus[0].id = 0;
2003e106:	2003e7b7          	lui	a5,0x2003e
	_kernel.cpus[0].irq_stack = (K_KERNEL_STACK_BUFFER(z_interrupt_stacks[0]) +
2003e10a:	2003f737          	lui	a4,0x2003f
	_kernel.cpus[0].id = 0;
2003e10e:	7a078793          	addi	a5,a5,1952 # 2003e7a0 <_kernel>
	_kernel.cpus[0].irq_stack = (K_KERNEL_STACK_BUFFER(z_interrupt_stacks[0]) +
2003e112:	fc070713          	addi	a4,a4,-64 # 2003efc0 <z_main_stack>
	_kernel.cpus[0].id = 0;
2003e116:	00078823          	sb	zero,16(a5)
	_kernel.cpus[0].irq_stack = (K_KERNEL_STACK_BUFFER(z_interrupt_stacks[0]) +
2003e11a:	c3d8                	sw	a4,4(a5)
2003e11c:	47a1                	li	a5,8
2003e11e:	3007a073          	csrs	mstatus,a5
	main_stack = (K_THREAD_STACK_BUFFER(z_main_stack) +
		      K_THREAD_STACK_SIZEOF(z_main_stack));

	irq_unlock(MSTATUS_IEN);

	__asm__ volatile (
2003e122:	2003f7b7          	lui	a5,0x2003f
2003e126:	3c078793          	addi	a5,a5,960 # 2003f3c0 <ep_cfg>
2003e12a:	813e                	mv	sp,a5
2003e12c:	000500e7          	jalr	a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
2003e130:	300477f3          	csrrci	a5,mstatus,8
	: "r" (main_stack), "r" (main_entry)
	: "memory");

	/* infinite loop */
	irq_lock();
	while (true) {
2003e134:	a001                	j	2003e134 <z_riscv_switch_to_main_no_multithreading+0x2e>

2003e136 <print_trace_address>:
#ifdef CONFIG_SYMTAB
	uint32_t offset = 0;
	const char *name = symtab_find_symbol_name(ra, &offset);
#endif /* CONFIG_SYMTAB */

	LOG_STACK_TRACE((*i)++, sfp, ra, name, offset);
2003e136:	411c                	lw	a5,0(a0)
2003e138:	0785                	addi	a5,a5,1
2003e13a:	c11c                	sw	a5,0(a0)

	return true;
}
2003e13c:	4505                	li	a0,1
2003e13e:	8082                	ret

2003e140 <walk_stackframe>:
{
2003e140:	fd810113          	addi	sp,sp,-40
2003e144:	d206                	sw	ra,36(sp)
2003e146:	d022                	sw	s0,32(sp)
2003e148:	ce26                	sw	s1,28(sp)
2003e14a:	c22a                	sw	a0,4(sp)
2003e14c:	c42e                	sw	a1,8(sp)
2003e14e:	c632                	sw	a2,12(sp)
2003e150:	c036                	sw	a3,0(sp)
2003e152:	c83a                	sw	a4,16(sp)
	if (esf != NULL) {
2003e154:	c2a9                	beqz	a3,2003e196 <walk_stackframe+0x56>
		sp = z_riscv_get_sp_before_exc(esf);
2003e156:	8536                	mv	a0,a3
2003e158:	37ad                	jal	2003e0c2 <z_riscv_get_sp_before_exc>
		ra = esf->mepc;
2003e15a:	4702                	lw	a4,0(sp)
		sp = z_riscv_get_sp_before_exc(esf);
2003e15c:	87aa                	mv	a5,a0
		ra = esf->mepc;
2003e15e:	5f58                	lw	a4,60(a4)
	ksp = (uintptr_t *)sp;
2003e160:	84be                	mv	s1,a5
	for (int i = 0; (i < MAX_STACK_FRAMES) && vrfy((uintptr_t)ksp, thread, esf) &&
2003e162:	4401                	li	s0,0
	uintptr_t *ksp, last_ksp = 0;
2003e164:	4301                	li	t1,0
	for (int i = 0; (i < MAX_STACK_FRAMES) && vrfy((uintptr_t)ksp, thread, esf) &&
2003e166:	4602                	lw	a2,0(sp)
2003e168:	45b2                	lw	a1,12(sp)
2003e16a:	47c2                	lw	a5,16(sp)
2003e16c:	cc3a                	sw	a4,24(sp)
2003e16e:	ca1a                	sw	t1,20(sp)
2003e170:	8526                	mv	a0,s1
2003e172:	9782                	jalr	a5
2003e174:	c53d                	beqz	a0,2003e1e2 <walk_stackframe+0xa2>
2003e176:	4352                	lw	t1,20(sp)
2003e178:	4762                	lw	a4,24(sp)
2003e17a:	06937463          	bgeu	t1,s1,2003e1e2 <walk_stackframe+0xa2>
	return (addr >= (uintptr_t)__text_region_start) && (addr < (uintptr_t)__text_region_end);
2003e17e:	2003d7b7          	lui	a5,0x2003d
2003e182:	58478613          	addi	a2,a5,1412 # 2003d584 <__initialize>
2003e186:	02c77b63          	bgeu	a4,a2,2003e1bc <walk_stackframe+0x7c>
		ra = ((struct arch_esf *)ksp++)->ra;
2003e18a:	4898                	lw	a4,16(s1)
2003e18c:	00448613          	addi	a2,s1,4
{
2003e190:	8326                	mv	t1,s1
2003e192:	84b2                	mv	s1,a2
2003e194:	bfc9                	j	2003e166 <walk_stackframe+0x26>
2003e196:	873e                	mv	a4,a5
	} else if ((csf == NULL) || (csf == &_current->callee_saved)) {
2003e198:	cb89                	beqz	a5,2003e1aa <walk_stackframe+0x6a>
2003e19a:	2003e7b7          	lui	a5,0x2003e
2003e19e:	7a078793          	addi	a5,a5,1952 # 2003e7a0 <_kernel>
2003e1a2:	479c                	lw	a5,8(a5)
2003e1a4:	07d1                	addi	a5,a5,20
2003e1a6:	00f71863          	bne	a4,a5,2003e1b6 <walk_stackframe+0x76>
		ra = (uintptr_t)walk_stackframe;
2003e1aa:	2003e737          	lui	a4,0x2003e
		sp = current_stack_pointer;
2003e1ae:	878a                	mv	a5,sp
		ra = (uintptr_t)walk_stackframe;
2003e1b0:	14070713          	addi	a4,a4,320 # 2003e140 <walk_stackframe>
2003e1b4:	b775                	j	2003e160 <walk_stackframe+0x20>
		sp = csf->sp;
2003e1b6:	431c                	lw	a5,0(a4)
		ra = csf->ra;
2003e1b8:	4358                	lw	a4,4(a4)
2003e1ba:	b75d                	j	2003e160 <walk_stackframe+0x20>
	return (addr >= (uintptr_t)__text_region_start) && (addr < (uintptr_t)__text_region_end);
2003e1bc:	2003e637          	lui	a2,0x2003e
2003e1c0:	5a060613          	addi	a2,a2,1440 # 2003e5a0 <__rodata_region_start>
2003e1c4:	fcc773e3          	bgeu	a4,a2,2003e18a <walk_stackframe+0x4a>
			if (!cb(cookie, ra, POINTER_TO_UINT(ksp))) {
2003e1c8:	4522                	lw	a0,8(sp)
2003e1ca:	4792                	lw	a5,4(sp)
2003e1cc:	8626                	mv	a2,s1
2003e1ce:	85ba                	mv	a1,a4
2003e1d0:	9782                	jalr	a5
2003e1d2:	c901                	beqz	a0,2003e1e2 <walk_stackframe+0xa2>
			i++;
2003e1d4:	0405                	addi	s0,s0,1
	for (int i = 0; (i < MAX_STACK_FRAMES) && vrfy((uintptr_t)ksp, thread, esf) &&
2003e1d6:	45a1                	li	a1,8
		ra = ((struct arch_esf *)ksp++)->ra;
2003e1d8:	4898                	lw	a4,16(s1)
2003e1da:	00448613          	addi	a2,s1,4
	for (int i = 0; (i < MAX_STACK_FRAMES) && vrfy((uintptr_t)ksp, thread, esf) &&
2003e1de:	fab419e3          	bne	s0,a1,2003e190 <walk_stackframe+0x50>
}
2003e1e2:	5092                	lw	ra,36(sp)
2003e1e4:	5402                	lw	s0,32(sp)
2003e1e6:	44f2                	lw	s1,28(sp)
2003e1e8:	02810113          	addi	sp,sp,40
2003e1ec:	8082                	ret

2003e1ee <in_fatal_stack_bound>:
	if (!IS_ALIGNED(addr, sizeof(uintptr_t))) {
2003e1ee:	00357793          	andi	a5,a0,3
{
2003e1f2:	872a                	mv	a4,a0
	if (!IS_ALIGNED(addr, sizeof(uintptr_t))) {
2003e1f4:	e795                	bnez	a5,2003e220 <in_fatal_stack_bound+0x32>
	if ((thread == NULL) || arch_is_in_isr()) {
2003e1f6:	c599                	beqz	a1,2003e204 <in_fatal_stack_bound+0x16>
	bool ret = arch_curr_cpu()->nested != 0U;

	arch_irq_unlock(key);
	return ret;
#else
	return _kernel.cpus[0].nested != 0U;
2003e1f8:	2003e7b7          	lui	a5,0x2003e
2003e1fc:	7a07a783          	lw	a5,1952(a5) # 2003e7a0 <_kernel>
		return false;
2003e200:	4501                	li	a0,0
	if ((thread == NULL) || arch_is_in_isr()) {
2003e202:	c385                	beqz	a5,2003e222 <in_fatal_stack_bound+0x34>
	start = (uintptr_t)K_KERNEL_STACK_BUFFER(z_interrupt_stacks[cpu_id]);
2003e204:	2003e7b7          	lui	a5,0x2003e
2003e208:	7c078793          	addi	a5,a5,1984 # 2003e7c0 <z_interrupt_stacks>
	return (addr >= start) && (addr < end);
2003e20c:	4501                	li	a0,0
2003e20e:	00f76a63          	bltu	a4,a5,2003e222 <in_fatal_stack_bound+0x34>
	end = start + CONFIG_ISR_STACK_SIZE;
2003e212:	6685                	lui	a3,0x1
2003e214:	80068693          	addi	a3,a3,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
2003e218:	97b6                	add	a5,a5,a3
	return (addr >= start) && (addr < end);
2003e21a:	00f73533          	sltu	a0,a4,a5
2003e21e:	8082                	ret
		return false;
2003e220:	4501                	li	a0,0
}
2003e222:	8082                	ret

2003e224 <z_riscv_unwind_stack>:

void z_riscv_unwind_stack(const struct arch_esf *esf, const _callee_saved_t *csf)
{
2003e224:	1141                	addi	sp,sp,-16
	int i = 0;

	EXCEPTION_DUMP("call trace:");
	walk_stackframe(print_trace_address, &i, _current, esf, in_fatal_stack_bound, csf);
2003e226:	2003e637          	lui	a2,0x2003e
{
2003e22a:	c606                	sw	ra,12(sp)
	walk_stackframe(print_trace_address, &i, _current, esf, in_fatal_stack_bound, csf);
2003e22c:	7a060613          	addi	a2,a2,1952 # 2003e7a0 <_kernel>
2003e230:	4610                	lw	a2,8(a2)
{
2003e232:	86aa                	mv	a3,a0
	walk_stackframe(print_trace_address, &i, _current, esf, in_fatal_stack_bound, csf);
2003e234:	2003e737          	lui	a4,0x2003e
2003e238:	2003e537          	lui	a0,0x2003e
{
2003e23c:	87ae                	mv	a5,a1
	walk_stackframe(print_trace_address, &i, _current, esf, in_fatal_stack_bound, csf);
2003e23e:	1ee70713          	addi	a4,a4,494 # 2003e1ee <in_fatal_stack_bound>
2003e242:	858a                	mv	a1,sp
2003e244:	13650513          	addi	a0,a0,310 # 2003e136 <print_trace_address>
	int i = 0;
2003e248:	c002                	sw	zero,0(sp)
	walk_stackframe(print_trace_address, &i, _current, esf, in_fatal_stack_bound, csf);
2003e24a:	3ddd                	jal	2003e140 <walk_stackframe>
	EXCEPTION_DUMP("");
}
2003e24c:	40b2                	lw	ra,12(sp)
2003e24e:	0141                	addi	sp,sp,16
2003e250:	8082                	ret

2003e252 <nordicsemi_nrf54l_init>:
int nordicsemi_nrf54l_init(void)
{
	/* Update the SystemCoreClock global variable with current core clock
	 * retrieved from the DT.
	 */
	SystemCoreClock = NRF_PERIPH_GET_FREQUENCY(DT_NODELABEL(cpu));
2003e252:	2003f7b7          	lui	a5,0x2003f
2003e256:	07a12737          	lui	a4,0x7a12
2003e25a:	40e7aa23          	sw	a4,1044(a5) # 2003f414 <SystemCoreClock>
	!defined(__ZEPHYR__)
	power_and_clock_configuration();
#endif

	return 0;
}
2003e25e:	4501                	li	a0,0
2003e260:	8082                	ret

2003e262 <vpr_init>:
    uint32_t reg = nrf_csr_read(VPRCSR_NORDIC_VPRNORDICCTRL);
2003e262:	7c0027f3          	csrr	a5,0x7c0
    reg = (reg & ~VPRCSR_NORDIC_VPRNORDICCTRL_ENABLERTPERIPH_Msk) | NRF_VPR_CSR_NORDIC_KEY_MASK;
2003e266:	af830737          	lui	a4,0xaf830
2003e26a:	1779                	addi	a4,a4,-2 # af82fffe <CONFIG_MCUBOOT_APPLICATION_IMAGE_NUMBER+0xaf82ffff>
2003e26c:	8ff9                	and	a5,a5,a4
    reg |= ((enable ? VPRCSR_NORDIC_VPRNORDICCTRL_ENABLERTPERIPH_Enabled :
2003e26e:	507d0737          	lui	a4,0x507d0
2003e272:	0705                	addi	a4,a4,1 # 507d0001 <__global_pointer$+0x307903f1>
2003e274:	8fd9                	or	a5,a5,a4
    nrf_csr_write(VPRCSR_NORDIC_VPRNORDICCTRL, reg);
2003e276:	7c079073          	csrw	0x7c0,a5
	 * To prevent redundant calls, do it here once.
	 */
	nrf_vpr_csr_rtperiph_enable_set(true);

	return 0;
}
2003e27a:	4501                	li	a0,0
2003e27c:	8082                	ret

2003e27e <riscv_clic_irq_enable>:
2003e27e:	f00017b7          	lui	a5,0xf0001
2003e282:	050a                	slli	a0,a0,0x2
2003e284:	953e                	add	a0,a0,a5
2003e286:	411c                	lw	a5,0(a0)
2003e288:	1007e793          	ori	a5,a5,256
2003e28c:	c11c                	sw	a5,0(a0)
#include <hal/nrf_vpr_clic.h>

void riscv_clic_irq_enable(uint32_t irq)
{
	nrf_vpr_clic_int_enable_set(NRF_VPRCLIC, irq, true);
}
2003e28e:	8082                	ret

2003e290 <riscv_clic_irq_disable>:
2003e290:	f00017b7          	lui	a5,0xf0001
2003e294:	050a                	slli	a0,a0,0x2
2003e296:	953e                	add	a0,a0,a5
2003e298:	411c                	lw	a5,0(a0)
2003e29a:	eff7f793          	andi	a5,a5,-257
2003e29e:	c11c                	sw	a5,0(a0)

void riscv_clic_irq_disable(uint32_t irq)
{
	nrf_vpr_clic_int_enable_set(NRF_VPRCLIC, irq, false);
}
2003e2a0:	8082                	ret

2003e2a2 <riscv_clic_irq_priority_set>:
	return nrf_vpr_clic_int_enable_check(NRF_VPRCLIC, irq);
}

void riscv_clic_irq_priority_set(uint32_t irq, uint32_t pri, uint32_t flags)
{
	nrf_vpr_clic_int_priority_set(NRF_VPRCLIC, irq, NRF_VPR_CLIC_INT_TO_PRIO(pri));
2003e2a2:	478d                	li	a5,3
{
2003e2a4:	4701                	li	a4,0
2003e2a6:	00b7e563          	bltu	a5,a1,2003e2b0 <riscv_clic_irq_priority_set+0xe>
2003e2aa:	059a                	slli	a1,a1,0x6
2003e2ac:	03f58713          	addi	a4,a1,63
                                                     nrf_vpr_clic_priority_t priority)
{
    NRFX_ASSERT(irq_num < NRF_VPR_CLIC_IRQ_COUNT);
    NRFX_ASSERT(priority != 0);

    p_reg->CLIC.CLICINT[irq_num] = (p_reg->CLIC.CLICINT[irq_num] & ~CLIC_CLIC_CLICINT_PRIORITY_Msk)
2003e2b0:	f00017b7          	lui	a5,0xf0001
2003e2b4:	050a                	slli	a0,a0,0x2
2003e2b6:	953e                	add	a0,a0,a5
2003e2b8:	411c                	lw	a5,0(a0)
                                   | (priority << CLIC_CLIC_CLICINT_PRIORITY_Pos);
2003e2ba:	0762                	slli	a4,a4,0x18
    p_reg->CLIC.CLICINT[irq_num] = (p_reg->CLIC.CLICINT[irq_num] & ~CLIC_CLIC_CLICINT_PRIORITY_Msk)
2003e2bc:	07a2                	slli	a5,a5,0x8
2003e2be:	83a1                	srli	a5,a5,0x8
                                   | (priority << CLIC_CLIC_CLICINT_PRIORITY_Pos);
2003e2c0:	8fd9                	or	a5,a5,a4
    p_reg->CLIC.CLICINT[irq_num] = (p_reg->CLIC.CLICINT[irq_num] & ~CLIC_CLIC_CLICINT_PRIORITY_Msk)
2003e2c2:	c11c                	sw	a5,0(a0)
}
2003e2c4:	8082                	ret

2003e2c6 <vevif_task_rx_max_channels_get>:
static uint32_t vevif_task_rx_max_channels_get(const struct device *dev)
{
	ARG_UNUSED(dev);

	return VEVIF_TASKS_NUM;
}
2003e2c6:	4505                	li	a0,1
2003e2c8:	8082                	ret

2003e2ca <vevif_task_rx_register_callback>:

static int vevif_task_rx_register_callback(const struct device *dev, uint32_t id,
					   mbox_callback_t cb, void *user_data)
{
	ARG_UNUSED(dev);
	uint8_t idx = id - TASKS_IDX_MIN;
2003e2ca:	ff058793          	addi	a5,a1,-16

	if (!vevif_task_rx_is_task_valid(id)) {
2003e2ce:	4741                	li	a4,16
	uint8_t idx = id - TASKS_IDX_MIN;
2003e2d0:	0ff7f793          	zext.b	a5,a5
		return -EINVAL;
2003e2d4:	5529                	li	a0,-22
	if (!vevif_task_rx_is_task_valid(id)) {
2003e2d6:	00e59f63          	bne	a1,a4,2003e2f4 <vevif_task_rx_register_callback+0x2a>
	}

	cbs.cb[idx] = cb;
2003e2da:	00279593          	slli	a1,a5,0x2
2003e2de:	2003e737          	lui	a4,0x2003e
	cbs.user_data[idx] = user_data;
2003e2e2:	0791                	addi	a5,a5,4 # f0001004 <CONFIG_MCUBOOT_APPLICATION_IMAGE_NUMBER+0xf0001005>
	cbs.cb[idx] = cb;
2003e2e4:	72470713          	addi	a4,a4,1828 # 2003e724 <cbs>
	cbs.user_data[idx] = user_data;
2003e2e8:	078a                	slli	a5,a5,0x2
	cbs.cb[idx] = cb;
2003e2ea:	95ba                	add	a1,a1,a4
	cbs.user_data[idx] = user_data;
2003e2ec:	973e                	add	a4,a4,a5
	cbs.cb[idx] = cb;
2003e2ee:	c190                	sw	a2,0(a1)
	cbs.user_data[idx] = user_data;
2003e2f0:	c754                	sw	a3,12(a4)

	return 0;
2003e2f2:	4501                	li	a0,0
}
2003e2f4:	8082                	ret

2003e2f6 <vevif_task_rx_set_enabled>:
static int vevif_task_rx_set_enabled(const struct device *dev, uint32_t id, bool enable)
{
	ARG_UNUSED(dev);
	uint8_t idx = id - TASKS_IDX_MIN;

	if (!vevif_task_rx_is_task_valid(id)) {
2003e2f6:	47c1                	li	a5,16
		return -EINVAL;
2003e2f8:	5529                	li	a0,-22
	if (!vevif_task_rx_is_task_valid(id)) {
2003e2fa:	04f59363          	bne	a1,a5,2003e340 <vevif_task_rx_set_enabled+0x4a>
{
2003e2fe:	1151                	addi	sp,sp,-12
	}

	if (enable) {
		if ((cbs.enabled_mask & BIT(id)) != 0U) {
2003e300:	2003e737          	lui	a4,0x2003e
{
2003e304:	c406                	sw	ra,8(sp)
		if ((cbs.enabled_mask & BIT(id)) != 0U) {
2003e306:	72470713          	addi	a4,a4,1828 # 2003e724 <cbs>
2003e30a:	5f1c                	lw	a5,56(a4)
			return -EALREADY;
2003e30c:	f8800513          	li	a0,-120
		if ((cbs.enabled_mask & BIT(id)) != 0U) {
2003e310:	0107d693          	srli	a3,a5,0x10
2003e314:	8a85                	andi	a3,a3,1
	if (enable) {
2003e316:	ce01                	beqz	a2,2003e32e <vevif_task_rx_set_enabled+0x38>
		if ((cbs.enabled_mask & BIT(id)) != 0U) {
2003e318:	ea81                	bnez	a3,2003e328 <vevif_task_rx_set_enabled+0x32>
		}

		cbs.enabled_mask |= BIT(id);
2003e31a:	66c1                	lui	a3,0x10
2003e31c:	8fd5                	or	a5,a5,a3
		irq_enable(vevif_irqs[idx]);
2003e31e:	4541                	li	a0,16
		cbs.enabled_mask |= BIT(id);
2003e320:	df1c                	sw	a5,56(a4)
		irq_enable(vevif_irqs[idx]);
2003e322:	e32ff0ef          	jal	ra,2003d954 <arch_irq_enable>

		cbs.enabled_mask &= ~BIT(id);
		irq_disable(vevif_irqs[idx]);
	}

	return 0;
2003e326:	4501                	li	a0,0
}
2003e328:	40a2                	lw	ra,8(sp)
2003e32a:	0131                	addi	sp,sp,12
2003e32c:	8082                	ret
		if ((cbs.enabled_mask & BIT(id)) == 0U) {
2003e32e:	deed                	beqz	a3,2003e328 <vevif_task_rx_set_enabled+0x32>
		cbs.enabled_mask &= ~BIT(id);
2003e330:	76c1                	lui	a3,0xffff0
2003e332:	16fd                	addi	a3,a3,-1 # fffeffff <CONFIG_MCUBOOT_APPLICATION_IMAGE_NUMBER+0xffff0000>
2003e334:	8ff5                	and	a5,a5,a3
		irq_disable(vevif_irqs[idx]);
2003e336:	4541                	li	a0,16
		cbs.enabled_mask &= ~BIT(id);
2003e338:	df1c                	sw	a5,56(a4)
		irq_disable(vevif_irqs[idx]);
2003e33a:	e1eff0ef          	jal	ra,2003d958 <arch_irq_disable>
2003e33e:	b7e5                	j	2003e326 <vevif_task_rx_set_enabled+0x30>
}
2003e340:	8082                	ret

2003e342 <vevif_task_rx_init>:
	IRQ_DIRECT_CONNECT(DT_INST_IRQ_BY_IDX(0, idx, irq), DT_INST_IRQ_BY_IDX(0, idx, priority), \
		    vevif_task_##idx##_rx_isr, 0)
#endif

static int vevif_task_rx_init(const struct device *dev)
{
2003e342:	1151                	addi	sp,sp,-12
2003e344:	c406                	sw	ra,8(sp)
    return nrf_csr_read(VPRCSR_NORDIC_TASKS);
}

NRF_STATIC_INLINE void nrf_vpr_csr_vevif_tasks_clear(uint32_t mask)
{
    nrf_csr_clear_bits(VPRCSR_NORDIC_TASKS, mask);
2003e346:	57fd                	li	a5,-1
2003e348:	7e07b073          	csrc	0x7e0,a5
	nrf_vpr_csr_vevif_tasks_clear(NRF_VPR_TASK_TRIGGER_ALL_MASK);

	LISTIFY(DT_NUM_IRQS(DT_DRV_INST(0)), VEVIF_IRQ_CONNECT, (;));
2003e34c:	4601                	li	a2,0
2003e34e:	4585                	li	a1,1
2003e350:	4541                	li	a0,16
2003e352:	e0aff0ef          	jal	ra,2003d95c <z_riscv_irq_priority_set>
2003e356:	4541                	li	a0,16
2003e358:	e08ff0ef          	jal	ra,2003d960 <z_riscv_irq_vector_set>

	return 0;
}
2003e35c:	40a2                	lw	ra,8(sp)
2003e35e:	4501                	li	a0,0
2003e360:	0131                	addi	sp,sp,12
2003e362:	8082                	ret

2003e364 <vevif_task_0_rx_isr>:
LISTIFY(DT_NUM_IRQS(DT_DRV_INST(0)), VEVIF_IRQ_FUN, ())
2003e364:	fd410113          	addi	sp,sp,-44
2003e368:	cc22                	sw	s0,24(sp)
{
#ifdef CONFIG_TRACING_ISR
	sys_trace_isr_enter();
#endif
	/* We need to increment this so that arch_is_in_isr() keeps working */
	++(arch_curr_cpu()->nested);
2003e36a:	2003e437          	lui	s0,0x2003e
2003e36e:	c23a                	sw	a4,4(sp)
2003e370:	d406                	sw	ra,40(sp)
2003e372:	d216                	sw	t0,36(sp)
2003e374:	d01a                	sw	t1,32(sp)
2003e376:	ce1e                	sw	t2,28(sp)
2003e378:	ca2a                	sw	a0,20(sp)
2003e37a:	c82e                	sw	a1,16(sp)
2003e37c:	c632                	sw	a2,12(sp)
2003e37e:	c436                	sw	a3,8(sp)
2003e380:	c03e                	sw	a5,0(sp)
2003e382:	7a040713          	addi	a4,s0,1952 # 2003e7a0 <_kernel>
2003e386:	431c                	lw	a5,0(a4)
2003e388:	0785                	addi	a5,a5,1
2003e38a:	c31c                	sw	a5,0(a4)
2003e38c:	67c1                	lui	a5,0x10
2003e38e:	7e07b073          	csrc	0x7e0,a5
	if (cbs.cb[idx] != NULL) {
2003e392:	2003e7b7          	lui	a5,0x2003e
2003e396:	72478793          	addi	a5,a5,1828 # 2003e724 <cbs>
2003e39a:	4398                	lw	a4,0(a5)
2003e39c:	7a040413          	addi	s0,s0,1952
2003e3a0:	cb09                	beqz	a4,2003e3b2 <vevif_task_0_rx_isr+0x4e>
		cbs.cb[idx](DEVICE_DT_INST_GET(0), channel, cbs.user_data[idx], NULL);
2003e3a2:	4fd0                	lw	a2,28(a5)
2003e3a4:	2003e537          	lui	a0,0x2003e
2003e3a8:	4681                	li	a3,0
2003e3aa:	45c1                	li	a1,16
2003e3ac:	5c850513          	addi	a0,a0,1480 # 2003e5c8 <__device_dts_ord_23>
2003e3b0:	9702                	jalr	a4
{
	ARG_UNUSED(swap);
	unsigned long mcause;

	/* Get the IRQ number */
	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
2003e3b2:	34202573          	csrr	a0,mcause
	mcause &= CONFIG_RISCV_MCAUSE_EXCEPTION_MASK;
2003e3b6:	0552                	slli	a0,a0,0x14

	/* Clear the pending IRQ */
	__soc_handle_irq(mcause);
2003e3b8:	8151                	srli	a0,a0,0x14
2003e3ba:	9c6ff0ef          	jal	ra,2003d580 <__soc_handle_irq>

	/* We are not in the ISR anymore */
	--(arch_curr_cpu()->nested);
2003e3be:	401c                	lw	a5,0(s0)
2003e3c0:	17fd                	addi	a5,a5,-1
2003e3c2:	c01c                	sw	a5,0(s0)
LISTIFY(DT_NUM_IRQS(DT_DRV_INST(0)), VEVIF_IRQ_FUN, ())
2003e3c4:	4462                	lw	s0,24(sp)
2003e3c6:	50a2                	lw	ra,40(sp)
2003e3c8:	5292                	lw	t0,36(sp)
2003e3ca:	5302                	lw	t1,32(sp)
2003e3cc:	43f2                	lw	t2,28(sp)
2003e3ce:	4552                	lw	a0,20(sp)
2003e3d0:	45c2                	lw	a1,16(sp)
2003e3d2:	4632                	lw	a2,12(sp)
2003e3d4:	46a2                	lw	a3,8(sp)
2003e3d6:	4712                	lw	a4,4(sp)
2003e3d8:	4782                	lw	a5,0(sp)
2003e3da:	02c10113          	addi	sp,sp,44
2003e3de:	30200073          	mret

2003e3e2 <vevif_event_tx_mtu_get>:
static int vevif_event_tx_mtu_get(const struct device *dev)
{
	ARG_UNUSED(dev);

	return 0;
}
2003e3e2:	4501                	li	a0,0
2003e3e4:	8082                	ret

2003e3e6 <vevif_event_tx_max_channels_get>:
static uint32_t vevif_event_tx_max_channels_get(const struct device *dev)
{
	ARG_UNUSED(dev);

	return VEVIF_EVENTS_NUM;
}
2003e3e6:	4505                	li	a0,1
2003e3e8:	8082                	ret

2003e3ea <vevif_event_tx_send>:
	if (!vevif_event_tx_is_valid(id)) {
2003e3ea:	47d1                	li	a5,20
		return -EINVAL;
2003e3ec:	5529                	li	a0,-22
	if (!vevif_event_tx_is_valid(id)) {
2003e3ee:	02f59263          	bne	a1,a5,2003e412 <vevif_event_tx_send+0x28>
		return -EMSGSIZE;
2003e3f2:	f8600513          	li	a0,-122
	if (msg != NULL) {
2003e3f6:	ee11                	bnez	a2,2003e412 <vevif_event_tx_send+0x28>
    nrf_csr_write(VPRCSR_NORDIC_EVENTS, value);
}

NRF_STATIC_INLINE void nrf_vpr_csr_vevif_events_trigger(uint32_t mask)
{
    nrf_csr_set_bits(VPRCSR_NORDIC_EVENTS, mask);
2003e3f8:	001007b7          	lui	a5,0x100
2003e3fc:	7e27a073          	csrs	0x7e2,a5
	while (!(nrf_vpr_csr_vevif_events_get() & BIT(id))) {
2003e400:	00100737          	lui	a4,0x100
    return nrf_csr_read(VPRCSR_NORDIC_EVENTS);
2003e404:	7e2027f3          	csrr	a5,0x7e2
2003e408:	8ff9                	and	a5,a5,a4
2003e40a:	dfed                	beqz	a5,2003e404 <vevif_event_tx_send+0x1a>
    nrf_csr_write(VPRCSR_NORDIC_EVENTS, value);
2003e40c:	7e205073          	csrwi	0x7e2,0
2003e410:	4501                	li	a0,0
}
2003e412:	8082                	ret

2003e414 <SystemInit>:
                }
            #endif
        #endif

    #endif
}
2003e414:	8082                	ret

2003e416 <arch_system_halt>:
2003e416:	300477f3          	csrrci	a5,mstatus,8
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
2003e41a:	a001                	j	2003e41a <arch_system_halt+0x4>

2003e41c <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const struct arch_esf *esf)
{
2003e41c:	1151                	addi	sp,sp,-12
2003e41e:	c406                	sw	ra,8(sp)
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
2003e420:	3fdd                	jal	2003e416 <arch_system_halt>

2003e422 <z_fatal_error>:
	arch_system_halt(reason);
}
/* LCOV_EXCL_STOP */

void z_fatal_error(unsigned int reason, const struct arch_esf *esf)
{
2003e422:	1151                	addi	sp,sp,-12
2003e424:	c406                	sw	ra,8(sp)
2003e426:	c222                	sw	s0,4(sp)
2003e428:	30047473          	csrrci	s0,mstatus,8
		LOG_ERR("Current thread: %p (%s)", thread, thread_name_get(thread));
	}

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
2003e42c:	3fc5                	jal	2003e41c <k_sys_fatal_error_handler>
			  :
			  : "r" (key & MSTATUS_IEN)
2003e42e:	8821                	andi	s0,s0,8
	__asm__ volatile ("csrs mstatus, %0"
2003e430:	30042073          	csrs	mstatus,s0
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
2003e434:	40a2                	lw	ra,8(sp)
2003e436:	4412                	lw	s0,4(sp)
2003e438:	0131                	addi	sp,sp,12
2003e43a:	8082                	ret

2003e43c <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
2003e43c:	00251713          	slli	a4,a0,0x2
2003e440:	2003e7b7          	lui	a5,0x2003e
2003e444:	0505                	addi	a0,a0,1
2003e446:	6fc78793          	addi	a5,a5,1788 # 2003e6fc <levels.0>
2003e44a:	050a                	slli	a0,a0,0x2
{
2003e44c:	1151                	addi	sp,sp,-12
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
2003e44e:	973e                	add	a4,a4,a5
2003e450:	97aa                	add	a5,a5,a0
{
2003e452:	c222                	sw	s0,4(sp)
2003e454:	c026                	sw	s1,0(sp)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
2003e456:	4300                	lw	s0,0(a4)
2003e458:	4384                	lw	s1,0(a5)
{
2003e45a:	c406                	sw	ra,8(sp)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
2003e45c:	00946763          	bltu	s0,s1,2003e46a <z_sys_init_run_level+0x2e>
		} else {
			result = entry->init_fn();
		}
		sys_trace_sys_init_exit(entry, level, result);
	}
}
2003e460:	40a2                	lw	ra,8(sp)
2003e462:	4412                	lw	s0,4(sp)
2003e464:	4482                	lw	s1,0(sp)
2003e466:	0131                	addi	sp,sp,12
2003e468:	8082                	ret
		const struct device *dev = entry->dev;
2003e46a:	4048                	lw	a0,4(s0)
		if (dev != NULL) {
2003e46c:	c901                	beqz	a0,2003e47c <z_sys_init_run_level+0x40>
			if ((dev->flags & DEVICE_FLAG_INIT_DEFERRED) == 0U) {
2003e46e:	01c54783          	lbu	a5,28(a0)
2003e472:	8b85                	andi	a5,a5,1
2003e474:	e391                	bnez	a5,2003e478 <z_sys_init_run_level+0x3c>
				result = do_device_init(dev);
2003e476:	2859                	jal	2003e50c <do_device_init>
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
2003e478:	0421                	addi	s0,s0,8
2003e47a:	b7cd                	j	2003e45c <z_sys_init_run_level+0x20>
			result = entry->init_fn();
2003e47c:	401c                	lw	a5,0(s0)
2003e47e:	9782                	jalr	a5
2003e480:	bfe5                	j	2003e478 <z_sys_init_run_level+0x3c>

2003e482 <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
2003e482:	1151                	addi	sp,sp,-12
	 * may perform memory management tasks (except for
	 * k_mem_map_phys_bare() which is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
2003e484:	2003e7b7          	lui	a5,0x2003e
2003e488:	4705                	li	a4,1

#if CONFIG_IRQ_OFFLOAD
	arch_irq_offload_init();
#endif
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
2003e48a:	450d                	li	a0,3
{
2003e48c:	c406                	sw	ra,8(sp)
	z_sys_post_kernel = true;
2003e48e:	72e78123          	sb	a4,1826(a5) # 2003e722 <z_sys_post_kernel>
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
2003e492:	376d                	jal	2003e43c <z_sys_init_run_level>
#endif

#if defined(CONFIG_STACK_POINTER_RANDOM) && (CONFIG_STACK_POINTER_RANDOM != 0)
	z_stack_adjust_initialized = 1;
#endif /* CONFIG_STACK_POINTER_RANDOM */
	boot_banner();
2003e494:	289d                	jal	2003e50a <boot_banner>
#ifdef CONFIG_STATIC_INIT_GNU
	z_static_init_gnu();
#endif /* CONFIG_STATIC_INIT_GNU */

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
2003e496:	4511                	li	a0,4
2003e498:	3755                	jal	2003e43c <z_sys_init_run_level>
	char **argv = prepare_main_args(&argc);
	(void)main(argc, argv);
#else
	extern int main(void);

	(void)main();
2003e49a:	bc2ff0ef          	jal	ra,2003d85c <main>
 * Exceptions raised by this thread may be recoverable.
 * (This is the default tag for a thread.)
 */
static inline void z_thread_essential_clear(struct k_thread *thread)
{
	thread->base.user_options &= ~K_ESSENTIAL;
2003e49e:	2003e7b7          	lui	a5,0x2003e
2003e4a2:	76078793          	addi	a5,a5,1888 # 2003e760 <z_main_thread>
2003e4a6:	00c7c703          	lbu	a4,12(a5)
2003e4aa:	9b79                	andi	a4,a4,-2
2003e4ac:	00e78623          	sb	a4,12(a5)

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif /* CONFIG_COVERAGE_DUMP */
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
2003e4b0:	40a2                	lw	ra,8(sp)
2003e4b2:	0131                	addi	sp,sp,12
2003e4b4:	8082                	ret

2003e4b6 <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
2003e4b6:	1151                	addi	sp,sp,-12
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
2003e4b8:	4501                	li	a0,0
{
2003e4ba:	c406                	sw	ra,8(sp)
	z_sys_init_run_level(INIT_LEVEL_EARLY);
2003e4bc:	3741                	jal	2003e43c <z_sys_init_run_level>
	__asm__ volatile ("li tp, 0");
2003e4be:	4201                	li	tp,0
#endif
#if CONFIG_BOARD_EARLY_INIT_HOOK
	board_early_init_hook();
#endif
	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
2003e4c0:	4505                	li	a0,1
2003e4c2:	3fad                	jal	2003e43c <z_sys_init_run_level>
#if defined(CONFIG_SMP)
	arch_smp_init();
#endif
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
2003e4c4:	4509                	li	a0,2
2003e4c6:	3f9d                	jal	2003e43c <z_sys_init_run_level>
#else
#ifdef ARCH_SWITCH_TO_MAIN_NO_MULTITHREADING
	/* Custom ARCH-specific routine to switch to main()
	 * in the case of no multi-threading.
	 */
	ARCH_SWITCH_TO_MAIN_NO_MULTITHREADING(bg_thread_main,
2003e4c8:	2003e537          	lui	a0,0x2003e
2003e4cc:	4681                	li	a3,0
2003e4ce:	4601                	li	a2,0
2003e4d0:	4581                	li	a1,0
2003e4d2:	48250513          	addi	a0,a0,1154 # 2003e482 <bg_thread_main>
2003e4d6:	3905                	jal	2003e106 <z_riscv_switch_to_main_no_multithreading>

2003e4d8 <z_impl_atomic_cas>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
2003e4d8:	300477f3          	csrrci	a5,mstatus,8
	 */
	BUILD_ASSERT(!IS_ENABLED(CONFIG_SMP));

	key = k_spin_lock(&lock);

	if (*target == old_value) {
2003e4dc:	4118                	lw	a4,0(a0)
2003e4de:	00b71863          	bne	a4,a1,2003e4ee <z_impl_atomic_cas+0x16>
		*target = new_value;
2003e4e2:	c110                	sw	a2,0(a0)
		ret = true;
2003e4e4:	4505                	li	a0,1
	__asm__ volatile ("csrs mstatus, %0"
2003e4e6:	8ba1                	andi	a5,a5,8
2003e4e8:	3007a073          	csrs	mstatus,a5
	}

	k_spin_unlock(&lock, key);

	return ret;
}
2003e4ec:	8082                	ret
	int ret = false;
2003e4ee:	4501                	li	a0,0
2003e4f0:	bfdd                	j	2003e4e6 <z_impl_atomic_cas+0xe>

2003e4f2 <atomic_get>:
 * @return The value read from <target>
 */
atomic_val_t atomic_get(const atomic_t *target)
{
	return *target;
}
2003e4f2:	4108                	lw	a0,0(a0)
2003e4f4:	8082                	ret

2003e4f6 <z_impl_atomic_set>:
 * @param value the value to write
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_set(atomic_t *target, atomic_val_t value)
{
2003e4f6:	87aa                	mv	a5,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
2003e4f8:	30047773          	csrrci	a4,mstatus,8
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
2003e4fc:	4108                	lw	a0,0(a0)
	*target = value;
2003e4fe:	c38c                	sw	a1,0(a5)
	__asm__ volatile ("csrs mstatus, %0"
2003e500:	00877793          	andi	a5,a4,8
2003e504:	3007a073          	csrs	mstatus,a5

	k_spin_unlock(&lock, key);

	return ret;
}
2003e508:	8082                	ret

2003e50a <boot_banner>:
#endif /* CONFIG_BOOT_CLEAR_SCREEN */

#ifdef CONFIG_BOOT_BANNER
	printk("*** " CONFIG_BOOT_BANNER_STRING " " BANNER_VERSION BANNER_POSTFIX " ***\n");
#endif /* CONFIG_BOOT_BANNER */
}
2003e50a:	8082                	ret

2003e50c <do_device_init>:
		k_object_init(dev);
	}
}

int do_device_init(const struct device *dev)
{
2003e50c:	1151                	addi	sp,sp,-12
2003e50e:	c222                	sw	s0,4(sp)
2003e510:	c406                	sw	ra,8(sp)
	int rc = 0;

	if (dev->ops.init != NULL) {
2003e512:	495c                	lw	a5,20(a0)
{
2003e514:	842a                	mv	s0,a0
	if (dev->ops.init != NULL) {
2003e516:	ef99                	bnez	a5,2003e534 <do_device_init+0x28>
	int rc = 0;
2003e518:	4501                	li	a0,0
			dev->state->init_res = rc;
		}
	}

	/* device initialization has been invoked */
	dev->state->initialized = true;
2003e51a:	4458                	lw	a4,12(s0)

	/* here, the value of rc is either 0 or +errno
	 * flip the sign to return a negative value on failure as expected
	 */
	return -rc;
}
2003e51c:	40a00533          	neg	a0,a0
	dev->state->initialized = true;
2003e520:	00174783          	lbu	a5,1(a4) # 100001 <CONFIG_PM_SRAM_SIZE+0xc0001>
2003e524:	0017e793          	ori	a5,a5,1
2003e528:	00f700a3          	sb	a5,1(a4)
}
2003e52c:	40a2                	lw	ra,8(sp)
2003e52e:	4412                	lw	s0,4(sp)
2003e530:	0131                	addi	sp,sp,12
2003e532:	8082                	ret
		rc = dev->ops.init(dev);
2003e534:	9782                	jalr	a5
		if (rc != 0) {
2003e536:	d16d                	beqz	a0,2003e518 <do_device_init+0xc>
			if (rc < 0) {
2003e538:	41f55793          	srai	a5,a0,0x1f
2003e53c:	8d3d                	xor	a0,a0,a5
2003e53e:	8d1d                	sub	a0,a0,a5
			if (rc > UINT8_MAX) {
2003e540:	0ff00793          	li	a5,255
2003e544:	00a7d463          	bge	a5,a0,2003e54c <do_device_init+0x40>
2003e548:	0ff00513          	li	a0,255
			dev->state->init_res = rc;
2003e54c:	445c                	lw	a5,12(s0)
2003e54e:	00a78023          	sb	a0,0(a5)
2003e552:	b7e1                	j	2003e51a <do_device_init+0xe>

2003e554 <memcmp>:
2003e554:	4701                	li	a4,0
2003e556:	00e61463          	bne	a2,a4,2003e55e <memcmp+0xa>
2003e55a:	4501                	li	a0,0
2003e55c:	8082                	ret
2003e55e:	00e507b3          	add	a5,a0,a4
2003e562:	0705                	addi	a4,a4,1
2003e564:	00e586b3          	add	a3,a1,a4
2003e568:	0007c783          	lbu	a5,0(a5)
2003e56c:	fff6c683          	lbu	a3,-1(a3)
2003e570:	fed783e3          	beq	a5,a3,2003e556 <memcmp+0x2>
2003e574:	40d78533          	sub	a0,a5,a3
2003e578:	8082                	ret

2003e57a <memcpy>:
2003e57a:	832a                	mv	t1,a0
2003e57c:	ca09                	beqz	a2,2003e58e <memcpy+0x14>
2003e57e:	00058383          	lb	t2,0(a1)
2003e582:	00730023          	sb	t2,0(t1)
2003e586:	167d                	addi	a2,a2,-1
2003e588:	0305                	addi	t1,t1,1
2003e58a:	0585                	addi	a1,a1,1
2003e58c:	fa6d                	bnez	a2,2003e57e <memcpy+0x4>
2003e58e:	8082                	ret

2003e590 <memset>:
2003e590:	832a                	mv	t1,a0
2003e592:	c611                	beqz	a2,2003e59e <memset+0xe>
2003e594:	00b30023          	sb	a1,0(t1)
2003e598:	167d                	addi	a2,a2,-1
2003e59a:	0305                	addi	t1,t1,1
2003e59c:	fe65                	bnez	a2,2003e594 <memset+0x4>
2003e59e:	8082                	ret
